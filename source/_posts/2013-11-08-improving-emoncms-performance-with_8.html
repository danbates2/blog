---
layout: post
title: Improving emoncms performance with Redis plus interesting consequences for
  SD cards.
date: '2013-11-08T08:08:00.003-08:00'
author: Trystan Lea
categories:
- emoncms
modified_time: '2013-11-08T15:31:04.774-08:00'
thumbnail: http://3.bp.blogspot.com/-azlnE7xK9UU/Unzhu8qmTFI/AAAAAAAACys/4BJJiI9HsRY/s72-c/index.jpeg
blogger_id: tag:blogger.com,1999:blog-2472065242652647619.post-1297328037399551205
blogger_orig_url: http://blog.openenergymonitor.org/2013/11/improving-emoncms-performance-with_8.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-azlnE7xK9UU/Unzhu8qmTFI/AAAAAAAACys/4BJJiI9HsRY/s1600/index.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="149" src="http://3.bp.blogspot.com/-azlnE7xK9UU/Unzhu8qmTFI/AAAAAAAACys/4BJJiI9HsRY/s200/index.jpeg" width="200" /></a></div><br />As part of recent work to improve the performance of emoncms because of high load's on emoncms.org there is now an emoncms branch that uses redis to store feed and input meta data including last feed time and value fields which where causing significant write load on the server.<br /><br />Using redis in this way leads to quite a big performance improvement and potentially could lengthen the lifespan of raspberrypi SD card systems significantly.<br /><br />I've been working on the redis implementation with Ynyr Edwards a good friend and an experienced software developer who recently joined Glyn and I helping us with development and running the shop. Ynyr had been telling me about the usefulness of in memory databases and caching for improving performance for long time. There appeared to be a significant amount of waiting on io going on on emoncms.org and the mysql processlist was full of last time and value updates to the feeds meta data table.<br /><br />In order to compare the use of mysql versus redis for storing input and feed meta data in emoncms a test was created that was representative of the typical kind of data input seen in emoncms.<br /><br />The test consisted of a node posting 3 power values, with each value being “logged to a feed” processed into kwh/d data and histogram data. So 9 feeds in total, three of them timestore and 6 mysql based.<br /><br />The node post rate was set to once a second and the time taken for each request was measured. After single request time's where measured a second test was carried out which involved sending request continuously and measuring the time taken to make 100 sequential requests from which the average requests per second value is determined.<br /><br />Its important to note that the following results are for <i>sequential</i> requests rather than concurrent requests. Its possible to achieve significantly higher request rates with concurrent requests which spawn many parallel apache processes. Sequantial requests give us a good base line test to work with.<br /><br />The CPU on the test machine was set to 2.0 GHz x 4 cores<br /><style type="text/css">P { margin-bottom: 0.21cm; }A:link {  }</style>  <br /><h3 style="margin-bottom: 0cm;">Testing Mysql</h3><div style="margin-bottom: 0cm;">The following results show the effect of turing off last input and feed time and value meta data entries in the pure mysql implementation: </div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>Mysql with all metadata switched on:</b></div><div style="margin-bottom: 0cm;">10x sequential posts, 31ms to 79ms @ 4x 2GHz, average 20 sequential req/s.  </div><div style="margin-bottom: 0cm;">With the processor set to 0.8GHz on all 4 cores the request rate was 10 sequential req/s</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">With a single poster process free-running the CPU is 7.4 us and wait is 11.5 wa</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>Mysql without input last time value being saved:</b></div><div style="margin-bottom: 0cm;">10x sequential, posts 26ms to 64ms, average: 25 sequential req/s</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>Mysql without input or feed last value but still histogram last value:</b></div><div style="margin-bottom: 0cm;">10x sequential posts: 18ms to 31ms, average: 46-48 req/s</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>Mysql without input or feed last value or histogram last value:</b></div><div style="margin-bottom: 0cm;">10x sequential posts: 10ms to 11ms, average 94-95 req/s</div><h3 style="margin-bottom: 0cm;">Redis&nbsp;</h3><div style="margin-bottom: 0cm;">Here are the results with the redis implementation that's up on github here: </div><div style="margin-bottom: 0cm;"><a href="https://github.com/emoncms/emoncms/tree/redismetadata"><span style="font-weight: normal;">https://github.com/emoncms/emoncms/tree/redismetadata</span></a></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;">All meta data enabled 11-14ms, 94-95req/s @ 2.0GHz</div><div style="margin-bottom: 0cm;">CPU us 22us, 0.0wa</div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>CPU Performance:</b></div><div style="font-weight: normal; margin-bottom: 0cm;">In the redis test the CPU utilisation was around 22%, the mysql CPU utilisation was around 7.4%. Idle CPU us is around 0.2%. Redis is however handling 4.7x the number of requests, if it where handling the same number of requests the cpu us may be around 22/4.7  ~4.7% us.</div><div style="font-weight: normal; margin-bottom: 0cm;"><br /></div><div style="font-weight: normal; margin-bottom: 0cm;"><b>Wait</b>  </div><div style="font-weight: normal; margin-bottom: 0cm;">We can see a significant reduction in the amount of time spent by the system waiting. With mysql every time a feed was updated, the time and value of the update was written to the mysql feeds table. The first idea was that this waiting was caused by waiting on mysql table locks, testing however with both MYISAM and InnoDB showed similar overall performance even through InnoDB is row locking while MyIsam table level locking. Looking at the disk write rate with vmstat and iotop however showed a really high write rate with mysql so it may be that the waiting was just waiting because the disk was working so hard, see more on this below.  </div><div style="font-weight: normal; margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>IO Disk write rate:</b></div><div style="font-weight: normal; margin-bottom: 0cm;">Here is the output from vmstat with the apache access and redis logs turned off.</div><div style="font-weight: normal; margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>Redis</b></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">2  0      0 4282700 352236 2002508    0    0     0     0 1670 44128 20  7 72  0 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4281496 352236 2002976    0    0     0    43 1622 44148 20  7 73  0 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4280636 352236 2003440    0    0     0     0 1651 44424 21  7 72  0 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4280096 352236 2003952    0    0     0  1793 1678 43999 21  6 72  0 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> 1  0      0 4279316 352236 2004416    0    0     0    49 1658 44106 20  7 73  0 </span></div><div style="margin-bottom: 0cm;"><br /></div><div style="margin-bottom: 0cm;"><b>MySQL</b></div><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><br /></span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4264420 352244 2041008    0    0     0  4280 1695 14833  7  3 79 11 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4264904 352248 2039972    0    0     0  4296 1777 15615  8  3 78 11 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4264664 352252 2040312    0    0     0  4477 1713 15072  7  3 79 12 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">1  0      0 4264440 352264 2040420    0    0     0  4355 1700 14982  7  2 79 11 </span></div><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span><br /><div style="margin-bottom: 0cm;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">0  1      0 4267364 352284 2037604    0    0     0  4332 1712 15012  7  2 79 12</span></div><div style="margin-bottom: 0cm;"><br /></div><div style="font-weight: normal; margin-bottom: 0cm;">Using a larger number of vm readings than the 5 listed above the average redis input was 215kb/s and mysql 4430kb/s, idle being 4kb/s. First its surprising how high the mysql write rate is and then second its surprising how large the reduction in the amount of disk writing done is, about 21x less and that's with 4.7 times the post rate. The reduction in the amount of writing could therefore be as much as 100x. The quanitiy of writes cannot only be explained by the kind of writes that are being done in emoncms, most of it appears to be due to ext4 filesystem journaling (61.16% of write capacity) while mysql is only responsible for a couple of percent.</div><div style="font-weight: normal; margin-bottom: 0cm;"><br /></div><div style="font-weight: normal; margin-bottom: 0cm;"><b>MySQL iotop </b></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-q8q8RbkJbDU/Unze5PlCgqI/AAAAAAAACyY/bC36YEUi5rY/s1600/iotop_mysql.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="118" src="http://1.bp.blogspot.com/-q8q8RbkJbDU/Unze5PlCgqI/AAAAAAAACyY/bC36YEUi5rY/s640/iotop_mysql.png" width="640" /></a></div><b>Redis iotop&nbsp; </b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-T61dmob77lE/Unze8J4DB6I/AAAAAAAACyg/Ig6EkJFipEg/s1600/iotop_redis.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="118" src="http://2.bp.blogspot.com/-T61dmob77lE/Unze8J4DB6I/AAAAAAAACyg/Ig6EkJFipEg/s640/iotop_redis.png" width="640" /></a></div><div style="font-weight: normal; margin-bottom: 0cm;"><br /></div><div style="font-weight: normal; margin-bottom: 0cm;"><b>Journaling</b><br /><i>"</i><i>A journaling file system is a file system that keeps track of the changes that will be made in a journal  (usually a circular log in a dedicated area of the file system) before  committing them to the main file system. In the event of a system crash  or power failure, such file systems are quicker to bring back online and  less likely to become corrupted" - <a href="http://en.wikipedia.org/wiki/Journaling_file_system.">http://en.wikipedia.org/wiki/Journaling_file_system.</a></i><br /><i>         <style type="text/css">P { margin-bottom: 0.21cm; }A:link {  }</style>  </i><br /><div style="font-weight: normal; margin-bottom: 0cm;"><a href="https://help.ubuntu.com/community/LinuxFilesystemsExplained">https://help.ubuntu.com/community/LinuxFilesystemsExplained</a></div><br /><b>Raspberry PI SD card installation</b></div><div style="font-weight: normal; margin-bottom: 0cm;">The problem with running emoncms on SD cards was that we where wearing the SD cards out in only a few months. If redis reduces the amount of writing by around 100x then this could mean a significantly longer SD card life span.<br /><br /></div><div style="font-weight: normal; margin-bottom: 0cm;">If in addition to using redis a filesystem without journaling is used the lifespan could be extended even further, although this does increase the risk of data corruption from power failure, but then if such failures are recoverable with a disk check on startup then that’s much better than a worn out SD card.<br /><br />To potentially improve things further the IPE Debian operating system could be put on a read only partition as is currently done with the oem gateway and the data could be placed on a write partition which could use the ext2 or fat32 filesystem both of which are non-journaling.&nbsp; <br /><br /></div><div style="font-weight: normal; margin-bottom: 0cm;"><b>Redis branch on github </b></div><div style="font-weight: normal; margin-bottom: 0cm;">If you'd like to try out the redis branch its up on github here: </div><div style="font-weight: normal; margin-bottom: 0cm;"><a href="https://github.com/emoncms/emoncms/tree/redismetadata">https://github.com/emoncms/emoncms/tree/redismetadata</a></div><div style="font-weight: normal; margin-bottom: 0cm;">You will need redis-server installed and phpredis: </div><div style="font-weight: normal; margin-bottom: 0cm;"><a href="https://github.com/nicolasff/phpredis">https://github.com/nicolasff/phpredis </a></div>