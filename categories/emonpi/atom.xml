<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: emonpi | Blog | OpenEnergyMonitor]]></title>
  <link href="https://blog.openenergymonitor.org/categories/emonpi/atom.xml" rel="self"/>
  <link href="https://blog.openenergymonitor.org/"/>
  <updated>2016-06-14T09:50:14+00:00</updated>
  <id>https://blog.openenergymonitor.org/</id>
  <author>
    <name><![CDATA[Glyn Hudson]]></name>
    <email><![CDATA[support@openenergymonitor.zendesk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Part 1/3: PlatformIO open-source embedded development ecosystem]]></title>
    <link href="https://blog.openenergymonitor.org/2016/06/platformio/"/>
    <updated>2016-06-12T10:00:00+00:00</updated>
    <id>https://blog.openenergymonitor.org/2016/06/platformio</id>
    <content type="html"><![CDATA[<p><strong>This post is part of a series:</strong></p>

<ul>
  <li>1/3: PlatfomIO overview &amp; compiling + uploading locally and on a Raspberry Pi</li>
  <li>2/3: Continuous testing and auto release binary generation using PlatformIO &amp; TravisCI</li>
  <li>3/3: Continuous Deployment (OTA to ESP8266)</li>
</ul>

<hr />

<p>Getting an Arduino based project (or other embedded platform) to compile and upload can be a pain. Making sure all the libraries are installed in the correct locations and of the correct versions can be tricky and time-consuming.</p>

<p>I’m sure many developers will agree that the tools we for embedded development are generally not as good as those used for web application development.</p>

<p>The Arduino team have done a good job with their IDE to try and make the embedded development tool-chain setup as easy as possible. However, I still find library management a cause of frustration. Especially since I move between computers and OS’s frequently.</p>

<p>Recently I have been using <a href="http://platformio.org">PlatformIO</a> and am rather impressed with the ease of setup, speed of compilation, uploading (auto port detection), and most importantly an excellent <a href="http://platformio.org/lib">library manager</a>.</p>

<blockquote>
  <p>PlatformIO is an open-source ecosystem for IoT development.</p>
</blockquote>

<blockquote>
  <p>Cross-platform build system, IDE integration and continuous testing. Arduino, Espressif, ARM and mbed compatible.</p>
</blockquote>

<p><img src="/images/pio-ide.png" alt="PlatformIO IDE" /></p>

<!--more-->

<p>Here are some things that have impressed me about PlatformIO (pio) after using it for a couple of weeks:</p>

<ul>
  <li><a href="https://github.com/platformio"><strong>Fully open-source</strong></a> with active and friendly dev community.</li>
  <li><strong>Easy to install</strong> - Pure python based installed using pip
    <ul>
      <li>Tool-chains are auto installed on first compile / upload e.g.
        <ul>
          <li>If trying to upload to Arduino avrdude will automatically be installed</li>
          <li>If trying to compile an ESP8266 project the ESP toolchain will be installed</li>
        </ul>
      </li>
      <li>Cross-platform (Linux, Windows and mac all work the same), this will make support much easier</li>
    </ul>
  </li>
  <li><strong>Supports all the main embedded platforms</strong>
    <ul>
      <li>atmelavr (Arduino), espressif (ESP8266), ststm32 (ARM etc.)</li>
    </ul>
  </li>
  <li><strong>Command line and IDE</strong>
    <ul>
      <li>At work I use pio via Atom IDE on Ubuntu</li>
      <li>At home, I use a Chromebook with Caret IDE and interact with pio via command-line</li>
      <li>When developing directly on an emonPi / RaspberryPi pio command-line works great - <em>Yes, that’s right pio works on a RaspberryPi to compile and upload code directly!</em></li>
    </ul>
  </li>
  <li><a href="http://platformio.org/lib"><strong>Excellent library manager</strong></a>
    <ul>
      <li>Libraries can be searched and reviewed using command-line or web 2.0 manager</li>
      <li>Required libraries can be specified in the <code class="highlighter-rouge">platformio.ini</code> file and if not present install is prompted upon compilation</li>
      <li>Specific library version (as defined in <code class="highlighter-rouge">library.json</code> <a href="https://github.com/openenergymonitor/EmonLib/blob/master/library.json">(emonLib example)</a>) or git commit SHA</li>
    </ul>
  </li>
  <li><strong>Fast compilation &amp; pain-free uploading</strong>
    <ul>
      <li>PlatformIO’s compiler is the <a href="https://twitter.com/krzychb2/status/729294573760065536">fastest in the business</a></li>
      <li>USB / Serial ports auto detected</li>
      <li>Since the emonPi has been added as a custom board PlatformIO can even upload direct to emonPi via RaspberryPi GPIO and trigger GPIO AVR reset, not more <a href="https://github.com/openenergymonitor/avrdude-rpi">hacked avrdude</a>.</li>
    </ul>
  </li>
  <li><strong>Easy integration with continuous testing &amp; deployment</strong>
    <ul>
      <li>Integration with TravisCI to enable compilation, code testing and binary (.hex / .bin) release generation in the cloud.</li>
      <li><a href="http://github.com/openenergymonitor/emonpi/">emonPi</a> and <a href="github.com/openenergymonitor/emonTxFirmware">emonTx</a> git repos are now enabled for continous-testing and auto binary generation on release tag…this is a step change in embedded development.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="example-compiling-emontx--emonpi-firmware">Example: Compiling emonTx / emonPi firmware</h2>

<p><a href="http://docs.platformio.org/en/latest/quickstart.html">PlatformIO has some excellent quick start docs</a> to cover setting up your first ‘blinky’ project, therefore I will not duplicate here. In this example I focus on setting up pio and compiling emonTx / emonPi firmware. This example assumes a totally bare metal machine with nothing installed except python (2.7 recommended). Pio works great on a Raspberry Pi.</p>

<p>This guide used command-line steps on Linux, if using windows or if you want to use the platformio IDE see <a href="http://platformio.org/get-started">PlatformIO Getting Started Page</a>.</p>

<p>The PlatformIO IDE or Atom IDE is excellent and very easy to use (self explanatory). This guide uses pio via command line as this gives a more hands-on experience to how pio is working.</p>

<h3 id="install-platformio">1. Install PlatformIO</h3>

<p>The easiest way if running Linux is to install use the install script, this installed pio via python pip and installs pip if not present. See <a href="http://docs.platformio.org/en/latest/installation.html#installer-script">PlatformIO installation docs</a>:</p>

<p><code class="highlighter-rouge">$ sudo python -c "$(curl -fsSL https://raw.githubusercontent.com/platformio/platformio/master/scripts/get-platformio.py)"</code></p>

<h3 id="clone-emontx--emonpi-repo">2. Clone emonTx / emonPi repo</h3>

<p>We’ll use the emonTx (V3 discrete sampling) as an example here but the steps are exactly the same for emonPi.</p>

<p><strong>emonTx V3</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ git clone https://github.com/openenergymonitor/emonTxFirmware`
$ cd emonTxFirmware/emonTxV3/RFM/emonTxV3.4/emonTxV3_4_DiscreteSampling
</code></pre>
</div>

<p><strong>emonPi</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ git clone https://github.com/openenergymonitor/emonpi`
cd emonpi/firmware
</code></pre>
</div>

<h3 id="compile-with-platformio">3. Compile with PlatformIO</h3>

<p><code class="highlighter-rouge">$ platformio run</code></p>

<p>or shorthand for the lazy</p>

<p><code class="highlighter-rouge">$ pio run</code></p>

<p><strong>That’s it!</strong> That’s all that’s needed to setup pio from scratch and compile emonTx firmware :-D</p>

<p>The first time platformIO is run it will ask to install the required libraries  and avr toolchain. The required libraries are defined in <a href="https://github.com/openenergymonitor/emonTxFirmware/blob/master/emonTxV3/RFM/emonTxV3.4/emonTxV3_4_DiscreteSampling/platformio.ini"><code class="highlighter-rouge">platformio.ini</code> in the emonTx discrete sampling firmware folder</a>:</p>

<p>e.g.</p>

<p><code class="highlighter-rouge">lib_install = 19,54,116,252</code></p>

<p>These numbers reference the Arduino libraries in the <a href="http://platformio.org/lib">pio library manager</a>:</p>

<ul>
  <li>19: DHT22</li>
  <li>54: Dallas Temperature</li>
  <li>116: emonLib</li>
  <li>252: JeeLib</li>
</ul>

<p>The latest version of the libraries are automatically cloned from their native git repos into the <code class="highlighter-rouge">~/platformio</code> folder.</p>

<p>If required specific versions can be installed e.g.:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ pio lib install 252 --version="e70c9d9f4e"
$ platformio lib install 54 --version="3.7.7"
</code></pre>
</div>

<h3 id="upload-using-platformio">3. Upload using PlatformIO</h3>

<h4 id="a-via-usb-to-uart-programmer-to-emontx">3a. Via USB to UART programmer to emonTx</h4>

<p><code class="highlighter-rouge">$ sudo platformio run --target upload</code></p>

<p>or lazy shorthand</p>

<p><code class="highlighter-rouge">$ sudo pio run -t upload</code></p>

<p>Pio will attempt to auto detect the USB programmer and upload :-)</p>

<p><em>Note: you will need <code class="highlighter-rouge">sudo</code> unless you have correctly <a href="https://github.com/platformio/platformio/blob/develop/scripts/99-platformio-udev.rules">configured udev rules</a>.</em></p>

<p>To list available serial ports:</p>

<p><code class="highlighter-rouge">$ pio serialports list</code></p>

<p>There is even a built in serial monitor</p>

<p><code class="highlighter-rouge">$ pio serialports monitor</code></p>

<h3 id="b-using-ttyama0-gpio-to-upload-direct-to-emonpi">3b. Using ttyAMA0 GPIO to upload direct to emonPi</h3>

<p>This is where things get very exciting, pio can compile the code directly on a Raspberry Pi. The latest version of pio (<del>due to be released in the next few weeks</del>, <a href="https://community.platformio.org/t/platformio-cli-2-10-0/381">released 2.10.0</a>) will have built in support for the emonPi auto-reset on upload using GPIO4</p>

<p>The emonPi board is defined in <code class="highlighter-rouge">platformio.ini</code> in the <a href="https://github.com/openenergymonitor/emonpi/blob/master/firmware/platformio.ini">emonpi/firmware folder</a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>board = emonpi
upload_port = /dev/ttyAMA0
</code></pre>
</div>

<p>All that is needed to compile and upload directly on the emonPi is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd ~/emonpi/firmware
$ sudo service emonhub stop
$ sudo pio run -t upload
$ sudo service emonhub start
</code></pre>
</div>

<p><em>Thanks a lot to <a href="https://github.com/ivankravets">Ivan Kravets</a> for helping integrate emonPi into the PlatfomIO ecosystem. <a href="https://github.com/platformio/platformio/commit/c5b5e80de4928cf91be59e675429b520e31d873a">View commit changes</a></em></p>

<hr />
<p>Stay tuned for part 2/3 of the PlatformIO post series which will cover setting up firmware continuous testing using Travis CI and auto compiled binary generation on release tag directly on github. This is currently live on the emonPi &amp; emonTx repos if you want a sneak preview. See <a href="https://github.com/openenergymonitor/emonpi/blob/master/.travis.yml">travis.yaml</a> file and Travis build status icon on the main emonpi repo <a href="https://github.com/openenergymonitor/emonpi/blob/master/README.md">Readme.md</a>.</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remote Control of LightWave RF plugs via MQTT using emonPi with OOK Tx]]></title>
    <link href="https://blog.openenergymonitor.org/2015/11/remote-control-of-lightwave-rf-plugs/"/>
    <updated>2015-11-26T17:09:00+00:00</updated>
    <id>https://blog.openenergymonitor.org/2015/11/remote-control-of-lightwave-rf-plugs</id>
    <content type="html"><![CDATA[<p>Using a Raspberry Pi as an emonPi / emonBase web-connected base station for energy monitoring has many advantages (maintainability, remote access, debugging, updated etc.) but it does seem rather wasteful to have a 900Mhz 1GB RAM machine being used to post a couple of integers to a web-server! The always-on nature of a web-connected base station and plenty of spare processing power makes it ideal to use the emonPi for more than just energy monitoring; home automation and heating control optimisation are obvious candidates. <br /><br /><br /><b>Hardware</b><br /><b><br /></b>Many home automation products such as RF plugs, relays and heating remotes use a simple OOK (On-Off-Keying) wireless protocol. UK company LightWaveRF produce a <a href="http://www.megamanuk.com/lightwaverf/products/power-control/">variety of RF plugs</a> and <a href="http://www.megamanuk.com/lightwaverf/products/inline-switching/jsjslw830/">relays</a> which can be controlled via OOK RF. The protocol is also compatible with some <a href="http://www.ebay.co.uk/itm/321887470042?_trksid=p2057872.m2749.l2649&amp;var=510834121070&amp;ssPageName=STRK%3AMEBIDX%3AIT">cheaper OOK learning receiver relays</a>.  While maybe not strictly open-source the protocol and been reverse engineered allowing plugs to be easily controlled from Arduino / Raspberry Pi. There is an active <a href="http://lightwaverfcommunity.org.uk/forum/">LightWaveRF</a> online community. Using off-the shelf hardware like this is a ‘safe’ way to control lights, heaters and appliances  around a home without getting our hands dirty dealing with with high voltages. These plugs and relays can be used to control anything from lights to immersion heaters, most LightWaveRF plugs/relays will switch up to 13A / 3kW.<br /><br />Note: OOK protocol by it’s simplistic nature is not particularly secure, I would not recommend controlling anything you don’t mind getting accidently switched.<br />&lt;div&gt;<br />&lt;/div&gt;An OOK transmitter can easily be added to the emonPi.  We have started stocking <a href="http://shop.openenergymonitor.com/ook-on-off-keying-transmitter-433mhz/">OOK transmitter modules in the OpenEnergyMonitor store</a> as well as adding an option to have OOK module factory installed on <a href="http://shop.openenergymonitor.com/emonpi/">new emonPi’s</a>. <br /><br />See <a href="http://wiki.openenergymonitor.org/index.php?title=EmonPi#OOK">emonPi Technical Hardware Wiki</a> for details how to retrofit OOK TX module to existing emonPi’s.<br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<a href="http://3.bp.blogspot.com/-ooKdNYl_8fA/Vlc-c0pyyJI/AAAAAAABj5o/M6wlA5rH_Ko/s1600/emonPi_lwrf.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="640" src="http://3.bp.blogspot.com/-ooKdNYl_8fA/Vlc-c0pyyJI/AAAAAAABj5o/M6wlA5rH_Ko/s640/emonPi_lwrf.png" width="600" /></a>&lt;/div&gt;<br /> <b>Software</b><br /><br />We have been working with <a href="https://github.com/lawrie">Lawrie Griffiths</a> from <a href="https://geekgrandad.wordpress.com/">Geek Grandad blog</a> to develop a <a href="https://github.com/lawrie/LightwaveRF">LightWaveRF MQTT service</a> to run on a Raspberry Pi to allow LightWaveRF plugs to be controlled via MQTT.<br /><br />&lt;table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td style="text-align: center;"&gt;<a href="https://www.electricalsupplies.co.uk/media/catalog/product/0/0/0019040_megaman-lightwave-rf-handheld-remote-controller-white.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://www.electricalsupplies.co.uk/media/catalog/product/0/0/0019040_megaman-lightwave-rf-handheld-remote-controller-white.jpeg" width="213" /></a>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;<br />&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;Once running a plug can be controlled by publishing to the ‘lwrf’ MQTT topic:<br /><br />E.g “1 1” switches on plug 1 while “1 0” switches off plug 1. Plugs can be paired in the usual LightWaveRF plug.<br /><br /><b>See <a href="http://wiki.openenergymonitor.org/index.php/EmonPi#LightWaveRF_OOK">emonPi technical Wiki</a> for how to install &amp; setup</b>.<br /><br />Existing LightWaveRF remotes can be emulated allowing plugs to be controlled from either emonPi MQTT or via the remote.<br /><br />Now our plugs can be controlled via MQTT there are a many of options open as to how to control either via interface openHAB (blog post coming soon..), nodeRED, android Tasker etc.<br /><br />I have been using nodeRED with input from android <a href="http://owntracks.org/">OwnTracks</a> running on my phone to detect when I’m home and turn on a couple of lights:<br /><br />&lt;div class="" style="clear: both; text-align: center;"&gt;<b>Demo:</b>&lt;/div&gt;&lt;div class="" style="clear: both; text-align: center;"&gt;<b><br /></b>&lt;/div&gt;&lt;div class="" style="clear: both; text-align: center;"&gt;Using NodeRED and OwnTracks to turn on LightWave RF sockets when I arrive home: &lt;/div&gt;&lt;div class="" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;/div&gt;&lt;div style="text-align: left;"&gt;<a href="http://3.bp.blogspot.com/-gt2MVmKylsk/VlOTJKgRb5I/AAAAAAABjrQ/hZUctXS_e_s/s1600/Screenshot%2B2015-11-23%2Bat%2B22.28.06.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="280" src="http://3.bp.blogspot.com/-gt2MVmKylsk/VlOTJKgRb5I/AAAAAAABjrQ/hZUctXS_e_s/s640/Screenshot%2B2015-11-23%2Bat%2B22.28.06.png" width="640" /></a>&lt;/div&gt;<b><br /></b>&lt;iframe allowfullscreen="" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/GVKXgS01Vqw/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/GVKXgS01Vqw?feature=player_embedded" width="320"&gt;&lt;/iframe&gt;<br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;Using android Tasker with  AutoVoice and MQTT plugins to control LightWaveRF sockets:&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;iframe allowfullscreen="" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/QjIqo4QsywA/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/QjIqo4QsywA?feature=player_embedded" width="320"&gt;&lt;/iframe&gt;<br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<b>Next Steps</b>&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;Now we can control appliances remotely via MQTT the next logical step is to add a mobile user interface. In my next blog post I plan to explore setting up <a href="http://www.openhab.org/">openHab</a> to control appliances. Here’s a early preview: &lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;iframe allowfullscreen="" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/6uF0qU30q-g/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/6uF0qU30q-g?feature=player_embedded" width="320"&gt;&lt;/iframe&gt;<br />&lt;div class="separator" style="clear: both; text-align: center;"&gt;<br />&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;We plan to include out-of-the-box support for OOK LightWave RF, nodeRED and openHab pre-configured on our next emonPi pre-built SD card. Due for release in December 2015.&lt;/div&gt;<br /></p>
]]></content>
  </entry>
  
</feed>
