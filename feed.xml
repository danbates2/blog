<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.3">Jekyll</generator><link href="https://blog.openenergymonitor.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.openenergymonitor.org/" rel="alternate" type="text/html" /><updated>2017-02-06T15:44:17+00:00</updated><id>https://blog.openenergymonitor.org/</id><title>Blog | OpenEnergyMonitor</title><subtitle>OpenEnergyMonitor Blog</subtitle><author><name>Glyn Hudson</name></author><entry><title>OpenEVSE EV Charge Controller Review</title><link href="https://blog.openenergymonitor.org/2017/01/openevse-build/" rel="alternate" type="text/html" title="OpenEVSE EV Charge Controller Review" /><published>2017-01-04T09:00:00+00:00</published><updated>2017-01-04T09:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2017/01/openevse-build</id><content type="html" xml:base="https://blog.openenergymonitor.org/2017/01/openevse-build/">&lt;p&gt;OpenEVSE (recently renamed to &lt;a href=&quot;https://www.openevse.com/&quot;&gt;OpenEV&lt;/a&gt;) design and build fully open-source EVSE (Electric Vehicle Supply Equipment) charge controllers for electric vehicles.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An EVSE charging station, is a device an electric car (EV) is plugged into to charge. It communicates to the car to agree on a charging rate that is the fastest and safest rate both the car and the power supply can support.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/leaf-openevse.jpg&quot; alt=&quot;openevse leaf&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;videoWrapper&quot;&gt;
&lt;iframe width=&quot;280&quot; height=&quot;157&quot; src=&quot;https://www.youtube.com/embed/A9D48V1D1G4&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build9.jpg&quot; alt=&quot;openevse build9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: this review is my account of using the OpenEVSE in the UK (240V single-phase AC), see OpenEVSE website for official build guides&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;features&quot;&gt;Features&lt;/h2&gt;

&lt;p&gt;The features that make the OpenEVSE charge controller interesting to us are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://openevse.dozuki.com/Guide/OpenEVSE+WiFi+%28Beta%29/14&quot;&gt;WiFi connectivity and remote control (via ESP8266)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Variable rate of charge: e.g. charge current can be varied to match available power&lt;/li&gt;
  &lt;li&gt;Integrated energy monitoring via custom hosted Emoncms &lt;a href=&quot;http://data.openevse.com/emoncms&quot;&gt;data.openevse.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Fully open-source :-)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;I recently swapped my ageing diesel car for an all-electric Nissan LEAF (it’s fantastic), so it felt like the perfect time to build and test an OpenEVSE charge controller unit!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Nissan LEAF charging from solar PV on a frosty morning:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nissan-leaf-solar-pv.jpg&quot; alt=&quot;nissan-leaf-solar-pv&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;safety&quot;&gt;Safety&lt;/h2&gt;

&lt;p&gt;Even though it is possible to charge an EV via a standard electrical outlet, it is not recommended for a number of reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Charging is very slow since the current is limited by the electrical outlet.&lt;/li&gt;
  &lt;li&gt;Drawing a significant current (approx 10/12A) for an extended period (up to 10hrs for a 24KWh Nissan LEAF and 30hrs for a 90KWh Tesla Model S!) puts stress on the domestic wiring resulting in heating of the wire &lt;a href=&quot;https://speakev.com/threads/house-fire-using-120v-trickle-charger.1708/&quot;&gt;or worse&lt;/a&gt; if the wiring is in a poor state.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Charging via a properly installed EVSE is the fastest and safest way to charge an EV at home.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OpenEVSE units have been designed to exceed the safety requirements for EV Charging Stations from SAE J1772, NEC and UL. Before supplying power to the car (and continuously while charging) the EVSE unit conducts a number of checks, no power is supplied until all the checks have passed. See &lt;a href=&quot;https://openev.freshdesk.com/support/solutions/articles/6000113537-openevse-safety-features&quot;&gt;OpenEVSE Safety Features&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;purchase&quot;&gt;Purchase&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Update: we are in communication with OpenEVSE to put together a UK/Europe specific OpeneEVSE package to resell via the &lt;a href=&quot;https://shop.openenergymonitor.com&quot;&gt;OpenEnergyMonitor Online Shop&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;OpenEVSE units can be purchased (kit or fully assembled) from the &lt;a href=&quot;https://store.openevse.com&quot;&gt;OpenEVSE online store&lt;/a&gt;, the units are shipped from California USA. I went for a &lt;a href=&quot;https://store.openevse.com/collections/frontpage/products/openevse-50a-charge-station-combo-with-enclosure&quot;&gt;P50D Level 2 Deluxe OpenEVSE kit&lt;/a&gt; with the &lt;a href=&quot;https://store.openevse.com/collections/frontpage/products/openevse-wifi-kit&quot;&gt;WiFi connection kit&lt;/a&gt; and &lt;a href=&quot;https://store.openevse.com/collections/frontpage/products/j1772-cable-40a-ultra-flexible-us-only&quot;&gt;J1772 Cable&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The OpenEVSE 50A L2 unit will charge any J1772 compliant car at up to 40A continous from a single phase 208-240V AC supply. However, you can dial back the current by setting the ‘max charge current’ to match your supply.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Full disclosure: Chris Howell from OpenEVSE made the unit available free of charge for me to evaluate and improve the Emoncms / OpenEnergyMonitor integration.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;assembly&quot;&gt;Assembly&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Warning:&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;Assembly of an EVSE requires wiring Alternating Current (AC) components that will be exposed to voltages from 100 to 250v. If you do not have the experience and knowledge required to safely work with AC voltages please consult with an experienced electrician for assistance and inspection of your work.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Assembly of the unit was straight forward following the &lt;a href=&quot;http://openevse.dozuki.com/Guide/OpenEVSE+50A+Charging+Station/8&quot;&gt;openEVSE build guide&lt;/a&gt;. No soldering was required, only basic tools e.g. screwdriver, wire strippers etc. Assembly probably took me a couple of hours. I took my time to do a high-quality job of assembling, this is particularly important given the high currents involved.&lt;/p&gt;

&lt;p&gt;The hardware components are all top quality, I was impressed by the attention to detail such as rubber seals around the LCD to waterproof the unit.&lt;/p&gt;

&lt;p&gt;The hardware inside the unit is split into two main components which are physically separated: a high voltage and high current relay and a low voltage control electronics which is the microcontroller (ATmega328p) ‘brains’ of the unit. My unit contained an OpenEVSE Plus V4 control unit &lt;a href=&quot;http://files.openevse.com/OpenEVSE_Plus_v4.pdf.&quot;&gt;see Datasheet&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build5.jpg&quot; alt=&quot;openevse build5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Rear PCB showing ATmega328p on the OpenEVSE Plus V4 controller:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build7.jpg&quot; alt=&quot;openevse build7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Build progress: charge controller, ground busbar, relay, LCD and mode button fixed into enclosure&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build2.jpg&quot; alt=&quot;openevse build2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The finished build: WiFi ESP8266 module is visible on the top left.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build3.jpg&quot; alt=&quot;openevse build3&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;Installation should be undertaken by a qualified electrician. The unit should be wired in using suitably rated cable ideally with a dedicated RCD circuit breaker. The max charge current of the unit should be set to match the supply circuit wiring.&lt;/p&gt;

&lt;h2 id=&quot;operation&quot;&gt;Operation&lt;/h2&gt;

&lt;p&gt;On first powerup some basic settings are set via the LCD menu using a combination of short/long presses of the front button. The menu system is impressively responsive considering it’s running from an ATmega328! The basic settings include max charge rate (set to match wiring), charging service level and date-time. Settings are saved to EEPROM and date-time is kept up-to-date via a RTC battery backup.&lt;/p&gt;

&lt;p&gt;The basic operation is very straightforward: just plug the car in and charging begins! Charging can be stopped/resumed by pressing the button on the front of the unit. Charging state is indicated by the backlight colour of the LCD and basic info such as current charging current and total kWh is displayed on the LCD.&lt;/p&gt;

&lt;p&gt;Here is a photo of the unit charging my Nissan LEAF @ 26A. At this charge rate my 6.6Kw charge (24Kwh battery) Nissan LEAF will charge from flat in about 4hrs:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build4.jpg&quot; alt=&quot;openevse build4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here’s a nice demo of the basic features of the unit. Credit: YouTube user civicturbo2009:&lt;/p&gt;

&lt;div class=&quot;videoWrapper&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/BFseWN7JhNM&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&quot;remote-datalogging&quot;&gt;Remote Datalogging&lt;/h3&gt;

&lt;p&gt;The Wifi kit (ESP8266) enables data logging from the OpenEVSE unit to a custom Emoncms server &lt;a href=&quot;http://data.openevse.com&quot;&gt;data.openevse.com&lt;/a&gt; via a local Wifi connection. The Wifi kit also allows remote control (see RAPI commands below).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build-emoncms.png&quot; alt=&quot;openevse build4&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;remote-control-via-rapi-commands&quot;&gt;Remote Control (via RAPI commands)&lt;/h3&gt;

&lt;p&gt;The OpenEVSE unit can be controlled and monitored remotely via serial RAPI (Remote API) commands. These commands can be &lt;a href=&quot;http://openevse.dozuki.com/Guide/Serial+Communications+with+OpenEVSE/13&quot;&gt;issued directly via serial&lt;/a&gt; or the OpenEVSE WiFi kit (ESP8266) can be added to allow RAPI commands to be issued remotely via an HTTP web interface.&lt;/p&gt;

&lt;h4 id=&quot;variable-charge-rate&quot;&gt;Variable Charge Rate&lt;/h4&gt;

&lt;p&gt;OpenEVSE charge controller can vary the charge rate, or more specifically the OpenEVSE can ‘request’ a particular charge rate from the car. It is actually the cars charging control electronics that varies the charge rate. OpenEVSE requests a particular charge rate by varying the pilot signal square wave duty cycle &lt;a href=&quot;https://openev.freshdesk.com/support/solutions/articles/6000052070-theory-of-operation&quot;&gt;see OpenEVSE technical theory of opperation&lt;/a&gt;. Charge rate can be varied from 6A (SAE/IEC standard min charge current) up to max charge rate (28A for my Nissan LEAF) in 1A increments. The car responds almost instantly to a charge rate adjustment request from the OpenEVSE controller. Charging can also be paused and resumed remotely if required.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$SC13&lt;/code&gt; will set the current charge current to 13A. The screen shot on the right below illustrates issuing the &lt;code class=&quot;highlighter-rouge&quot;&gt;$SC 13&lt;/code&gt; RAPI command into the OpenEVSE local web page interface (served from ESP8266). The screenshot on the left shows the effect of reduction in charge rate as monitored by emonPi displayed using Emoncms:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/openevse-build6.png&quot; alt=&quot;openevse build6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Rapi commands can also be issued directly via a single HTTP request. Eg. the same rapi command to set charging rate to 13A:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://192.168.0.108/r?rapi=%24SC+13&quot;&gt;http://192.168.0.108/r?rapi=%24SC+13&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To sleep (pause a charge) issue RAPI command &lt;code class=&quot;highlighter-rouge&quot;&gt;$FS&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://192.168.0.108/r?rapi=%24FS&quot;&gt;http://192.168.0.108/r?rapi=%24FS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To enable (start a charge) issue RAPI command &lt;code class=&quot;highlighter-rouge&quot;&gt;$FE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://192.168.0.108/r?rapi=%24FE&quot;&gt;http://192.168.0.108/r?rapi=%24FE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Assuming &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.0.108&lt;/code&gt; is the local IP address of the OpenEVSE ESP.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There is also an &lt;a href=&quot;https://github.com/tiramiseb/python-openevse&quot;&gt;OpenEVSE RAPI command python library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;RAPI commands can be used to control and check the status of all OpenEVSE functions. A full list of RAPI commands can be found in the &lt;a href=&quot;https://github.com/lincomatic/open_evse/blob/stable/rapi_proc.h&quot;&gt;OpenEVSE plus source code&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;future-developments&quot;&gt;Future developments&lt;/h4&gt;

&lt;p&gt;I would like to add MQTT support to the &lt;a href=&quot;https://github.com/chris1howell/OpenEVSE_RAPI_WiFi_ESP8266&quot;&gt;OpenEVSE WiFi ESP8266 firmware&lt;/a&gt;, this will allow RAPI commands to be issued via MQTT over an authenticated local MQTT server e.g. emonPi / RaspberryPi or remote MQTT server e.g. Hive MQTT / Cloud MQTT. Using MQTT will make it easier and more secure to control the OpenEVSE. MQTT allow easy integration with all home automation and control platforms e.g nodeRED / OpenHAB / Emoncms.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; I have recently added RAPI commands over MQTT support to the &lt;a href=&quot;https://github.com/chris1howell/OpenEVSE_RAPI_WiFi_ESP8266/tree/Devolopment&quot;&gt;OpenEVSE ESP8266 code currently in the dev branch&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&quot;https://community.openenergymonitor.org/t/openevse-ev-charging-station-with-emoncms-wifi-integration/2439/21&quot;&gt;this forum thread&lt;/a&gt; for related discussion.&lt;/p&gt;

&lt;h3 id=&quot;open-source&quot;&gt;Open Source&lt;/h3&gt;

&lt;p&gt;The source code and CAD hardware designs for the OpenEVSE unit can be found on github:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/OpenEVSE/OpenEVSE_LCD&quot;&gt;OpenEVSE I2C LCD + RTC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/OpenEVSE/OpenEVSE_PLUS&quot;&gt;OpenEVSE Plus Controller Hardware&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lincomatic/open_evse/blob/stable/rapi_proc.h&quot;&gt;OpenEVSE Plus Controller Firmware&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/OpenEVSE/Default_Firmware_Loads&quot;&gt;OpenEVSE Plus Controller Pre Compiled Firmware&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/chris1howell/OpenEVSE_RAPI_WiFi_ESP8266&quot;&gt;OpenEVSE ESP8266 Wifi firmware&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/OpenEVSE/Enclosures&quot;&gt;OpenEVSE Enclosure&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;related-forum-threads&quot;&gt;Related Forum Threads&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://community.openenergymonitor.org/t/openevse-ev-charging-station-with-emoncms-wifi-integration/2439/21&quot;&gt;OpenEnergyMonitor community forum thread documenting OpenEVSE build&lt;/a&gt;&lt;/p&gt;</content><author><name>Glyn Hudson</name></author><summary>OpenEVSE (recently renamed to OpenEV) design and build fully open-source EVSE (Electric Vehicle Supply Equipment) charge controllers for electric vehicles.


  An EVSE charging station, is a device an electric car (EV) is plugged into to charge. It communicates to the car to agree on a charging rate that is the fastest and safest rate both the car and the power supply can support.










Note: this review is my account of using the OpenEVSE in the UK (240V single-phase AC), see OpenEVSE website for official build guides

Features

The features that make the OpenEVSE charge controller interesting to us are:


  WiFi connectivity and remote control (via ESP8266)
  Variable rate of charge: e.g. charge current can be varied to match available power
  Integrated energy monitoring via custom hosted Emoncms data.openevse.com
  Fully open-source :-)


I recently swapped my ageing diesel car for an all-electric Nissan LEAF (it’s fantastic), so it felt like the perfect time to build and test an OpenEVSE charge controller unit!

Nissan LEAF charging from solar PV on a frosty morning:</summary></entry><entry><title>Introducing emonTH V2</title><link href="https://blog.openenergymonitor.org/2016/09/emonth2/" rel="alternate" type="text/html" title="Introducing emonTH V2" /><published>2016-09-29T09:00:00+00:00</published><updated>2016-09-29T09:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/09/emonth2</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/09/emonth2/">&lt;p&gt;The emonTH V2 is an open-source, wireless, battery-powered temperature and humidity monitoring node.&lt;/p&gt;

&lt;p&gt;The emonTH V2 features a Silicon Labs &lt;strong&gt;&lt;a href=&quot;https://www.silabs.com/Support%20Documents%2FTechnicalDocs%2FSi7021-A20.pdf&quot;&gt;Si7021&lt;/a&gt;&lt;/strong&gt; temperature and humidity sensor instead of the &lt;a href=&quot;http://shop.openenergymonitor.com/dht22-temperature-humidity-sensor-am2302/&quot;&gt;DHT22 sensor&lt;/a&gt;. The Si7021 is more accurate and significantly (2000 times!) lower power then the DHT22. This will result in an increase in the emonTH battery life; from 10 months to several years. The Si7021 is also &lt;em&gt;much&lt;/em&gt; smaller than the DHT22.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonth2.jpg&quot; alt=&quot;emonTH V2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The Si7021 sensor can be seen in the top right-hand corner of the PCB. The white film on top of the sensor is a dust film and should not be removed. The dust film is factory fitted and will protect the sensor from dust and air contaminants.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonth_green.png&quot; alt=&quot;emonTH image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://shop.openenergymonitor.com/emonth-temperature-humidity-node/&quot;&gt;The emonTH V2 is now shipping via our online shop&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As with all our hardware units the emonTH V2 is &lt;a href=&quot;https://github.com/openenergymonitor/emonth2&quot;&gt;fully open-source&lt;/a&gt; and manufactured locally in North Wales, UK using non-conflict materials lead-free processes.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;emonth-v2-features&quot;&gt;emonTH V2 Features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Microcontroller: Arduino compatible ATmega328p&lt;/li&gt;
  &lt;li&gt;Internal Sensor: Si7021 (internal temperature &amp;amp; Humidity)&lt;/li&gt;
  &lt;li&gt;External Sensor (OPTIONAL): DS18B20 external temperature sensor. See hardware wiki for connections&lt;/li&gt;
  &lt;li&gt;Power: 2 x AA from onboard holder, LTC3525 3.3V DC-DC boost converter to extend battery life&lt;/li&gt;
  &lt;li&gt;RF Radio: RFM69CW 433Mhz&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;si7021-temperature--humidity-sensor&quot;&gt;Si7021 Temperature &amp;amp; Humidity Sensor&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Silicon Labs SI7021-A20-GM1R&lt;/li&gt;
  &lt;li&gt;Power supply 1.9V - 3.6V&lt;/li&gt;
  &lt;li&gt;Operating range humidity 0-80%RH; temperature -40~125 deg C&lt;/li&gt;
  &lt;li&gt;Accuracy humidity +-3%RH&lt;/li&gt;
  &lt;li&gt;Accuracy Temperature: +-0.4 degC&lt;/li&gt;
  &lt;li&gt;Active current: 150uA&lt;/li&gt;
  &lt;li&gt;Sleep current 0.06uA&lt;/li&gt;
  &lt;li&gt;Measurement time: 2.6ms = 10ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See &lt;a href=&quot;https://github.com/openenergymonitor/emonth2/tree/master/sensor&quot;&gt;DHT22 VS Si7021 technical comparison table&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/openenergymonitor/emonth2&quot;&gt;emonTH V2 GitHub&lt;/a&gt; (open-hardware &amp;amp; software)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Glyn Hudson</name></author><summary>The emonTH V2 is an open-source, wireless, battery-powered temperature and humidity monitoring node.

The emonTH V2 features a Silicon Labs Si7021 temperature and humidity sensor instead of the DHT22 sensor. The Si7021 is more accurate and significantly (2000 times!) lower power then the DHT22. This will result in an increase in the emonTH battery life; from 10 months to several years. The Si7021 is also much smaller than the DHT22.



The Si7021 sensor can be seen in the top right-hand corner of the PCB. The white film on top of the sensor is a dust film and should not be removed. The dust film is factory fitted and will protect the sensor from dust and air contaminants.



The emonTH V2 is now shipping via our online shop

As with all our hardware units the emonTH V2 is fully open-source and manufactured locally in North Wales, UK using non-conflict materials lead-free processes.</summary></entry><entry><title>Summer Placement</title><link href="https://blog.openenergymonitor.org/2016/09/summer-placement/" rel="alternate" type="text/html" title="Summer Placement" /><published>2016-09-01T09:00:00+00:00</published><updated>2016-09-01T09:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/09/summer-placement</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/09/summer-placement/">&lt;p&gt;Hi! My name is Eben I’ve been working with OpenEnergyMonitor for the past 10 weeks as part of a summer placement organised by &lt;a href=&quot;http://www.arloesigwyneddwledig.com/&quot;&gt;Arloesi Gwynedd Wledig&lt;/a&gt;; a local project aimed at highlighting the local tech sector employment opportunities on &lt;a href=&quot;http://parcmenai.co.uk/&quot;&gt;Parc Menai&lt;/a&gt; the business park where we are located in North Wales, and the difficulties that they face, as well as the great perks of living in such a beautiful area.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eben.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The scheme organised placements for four students in four seperate tech companies in Parc Menai. Here is a video with highlights the whole 10 week scheme:&lt;/p&gt;

&lt;div class=&quot;videoWrapper&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/N2v2a3ZJq0E&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Working in a small company in a rural area, that has such a large online community has really opened my eyes to the possibilities that the internet and the digital age can offer, in that people are no longer bound to cities. Increasing infrastructure development in terms of roads and internet speeds has increased this mobility further, and I look forward to the growth that this will no doubt provide in Gwynedd. OpenEnergyMonitor is for me the perfect example of a growing business that has been made possible by opensource development, global connections and communities, and new technology.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;me-and-gwynedd&quot;&gt;Me, and Gwynedd&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Gwynedd&quot;&gt;Gwynedd&lt;/a&gt; is area that we live in North Wales. I am currently studying physics at Cardiff University, and originally from &lt;a href=&quot;https://cy.wikipedia.org/wiki/Dyffryn_Nantlle&quot;&gt;Dyffryn Nantlle&lt;/a&gt;. As you can probably tell by my failure to find a decent photo of myself doing anything else, I’m (like Glyn and Trystan)  a keen climber, and that’s been my primary reason for wanting to return to Gwynedd to work, with a long list of climbs in the Llanberis Pass, Ogwen Valley, and Tremadog, and more that I wanted to have a go at. It’s a great way to appreciate Gwynedd, in my opinion, and I even got to go climbing with Glyn.&lt;/p&gt;

&lt;p&gt;Check out the video here:&lt;/p&gt;

&lt;div class=&quot;videoWrapper&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/CzPMPY-I3_I&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;It’s a little cheesy, but we got to climb with RC drones filming, so that was pretty sweet :-)&lt;/p&gt;

&lt;p&gt;The other strong pull, for me, was the Welsh language; &lt;a href=&quot;https://en.wikipedia.org/wiki/Welsh_language&quot;&gt;Cymraeg&lt;/a&gt;. I’ve spent two years now living and studying down in Cardiff, and the switch to the academic and leisure medium of English has been a little challenging, and it’s always amazing to come back to Gwynedd, and hear Welsh on the street and in the shops, as well as at home, and in the OpenEnergyMonitor workplace. A lot of our culture is tied intimately to the language, and it’s been good to feel that again.&lt;/p&gt;

&lt;h2 id=&quot;what-ive-been-up-to&quot;&gt;What I’ve been up to&lt;/h2&gt;

&lt;p&gt;During my time at the company, I’ve learnt how to write basic software from scratch (I’ve only ever done experimental analysis using python previously) to Arduino boards and the ESP8266, my eyes have been opened to the possibilities of GitHub, and other resources. I’ve played around with adding a DHT22 sensor to the ESP8266 and &lt;a href=&quot;https://github.com/openenergymonitor/EmonESP/pull/7&quot;&gt;creating an DHT22 &amp;gt; Emoncms example&lt;/a&gt; which I contributed to the emonESP GitHub repository.&lt;/p&gt;

&lt;p&gt;I’ve also had the pleasure of working with Gwil on preparation and order fulfilment for the OpenEnergyMonitor shop, which has been fun!&lt;/p&gt;

&lt;p&gt;Another interesting experience was the few times I visited the local electronics factory, &lt;a href=&quot;http://www.dferrantigroup.com/pcb-population-test/&quot;&gt;Denis Ferranti&lt;/a&gt;  where the boards are all manufactured. It was really cool to see the manufacturing process, and the quality of the equipment there. It’s great to know that OpenEnergyMonitor are able to manufacuture locally, which contributes to the local economy.&lt;/p&gt;

&lt;h2 id=&quot;the-scheme&quot;&gt;The Scheme&lt;/h2&gt;

&lt;p&gt;Through the project that organised this placement opportunity, the four of us students (all at different companies) were asked to come to a conclusion on the situation regarding tech jobs in Gwynedd, and the so-called ‘brain drain’, as the best and brightest graduates leave the area to embrace city life.&lt;/p&gt;

&lt;p&gt;The overall conclusion was that perceptions need to change. People overwhelmingly do not view Gwynedd as a place with lots of potential for tech jobs, but research has shown that the truth is the very opposite, with Parc Menai alone set to be the location of around 200 new jobs in the next few years. At a presentation at Pontio, at Bangor university, the four of us students reccomended modernisation of the school syllabus, a closer relationship between companies and schools, more grassroots tech events (a brilliant example of this sort of thing are the events held by &lt;a href=&quot;https://www.facebook.com/NorthWalesTechnology/?fref=ts&quot;&gt;North Wales Tech&lt;/a&gt; (check them out!), and better utilisation of social media by companies looking for skilled graduates.&lt;/p&gt;

&lt;p&gt;I’d like to thank Glyn, Trystan, and Gwil for making this summer such an incredibly fun and rewarding one, as well as an extremely eye opening one. I’m sure the company has a huge future, and I for one will be following future products and developments with keen interest.&lt;/p&gt;

&lt;p&gt;Today is my last day, and it’s a little sad. I’m writing this blog but should probably stop and help Gwil assemble some more emonTH’s.. :-)&lt;/p&gt;

&lt;p&gt;Eben, out.&lt;/p&gt;

&lt;p&gt;There also will soon be footage of the Dennis Ferranti factory we visited, I will post it here as soon as it arrives!
Thanks for reading!&lt;/p&gt;</content><author><name>Eben Myrddin Muse</name></author><summary>Hi! My name is Eben I’ve been working with OpenEnergyMonitor for the past 10 weeks as part of a summer placement organised by Arloesi Gwynedd Wledig; a local project aimed at highlighting the local tech sector employment opportunities on Parc Menai the business park where we are located in North Wales, and the difficulties that they face, as well as the great perks of living in such a beautiful area.



The scheme organised placements for four students in four seperate tech companies in Parc Menai. Here is a video with highlights the whole 10 week scheme:






  Working in a small company in a rural area, that has such a large online community has really opened my eyes to the possibilities that the internet and the digital age can offer, in that people are no longer bound to cities. Increasing infrastructure development in terms of roads and internet speeds has increased this mobility further, and I look forward to the growth that this will no doubt provide in Gwynedd. OpenEnergyMonitor is for me the perfect example of a growing business that has been made possible by opensource development, global connections and communities, and new technology.</summary></entry><entry><title>EcoHome Lab: From Monitoring to Control</title><link href="https://blog.openenergymonitor.org/2016/08/ecohomelab-control/" rel="alternate" type="text/html" title="EcoHome Lab: From Monitoring to Control" /><published>2016-08-12T18:00:00+00:00</published><updated>2016-08-12T18:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/08/ecohomelab-control</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/08/ecohomelab-control/">&lt;p&gt;Last night I attended &lt;a href=&quot;https://www.meetup.com/Eco-Home-Lab-Manchester/events/230714252/&quot;&gt;EcoHomeLab meetup&lt;/a&gt; in Manchester organised by the &lt;a href=&quot;http://carbon.coop/&quot;&gt;CarbonCoop&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;EcoHomeLab monthly meetups at &lt;a href=&quot;https://madlab.org.uk/&quot;&gt;MadLab&lt;/a&gt; brings householders and green-technologists together to take control of home energy use and generation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It was great fun to catch up with regular faces as well as meet many new interesting people.&lt;/p&gt;

&lt;p&gt;I gave a short presentation overview of our efforts as OpenEnergyMonitor to make it as easy as possible for people to get started with energy monitoring and control (home automation) with a sustainability / energy saving focus.&lt;/p&gt;

&lt;p&gt;I presented the recent work we have been doing to integrate platforms such as MQTT, Node-RED and openHAB ready-installed and pre-configured on the emonPi, our RaspberryPi based energy monitoring platform. These additional platforms run alongside Emoncms on the emonPi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;See the &lt;a href=&quot;http://guide.openenergymonitor.org/integrations/&quot;&gt;Integrations section of our user guide for more info&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here are copy of my slides from the event:&lt;/p&gt;

&lt;iframe src=&quot;https://docs.google.com/presentation/d/1qSaxiB2tAgMe3ehQ08E9_r340y9HgHUOYvyUvsHd55I/embed?start=false&amp;amp;loop=false&amp;amp;delayms=10000&quot; frameborder=&quot;0&quot; width=&quot;529&quot; height=&quot;426&quot; allowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot; style=&quot;max-width: 100%;&quot;&gt;&lt;/iframe&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a class=&quot;attachment&quot; href=&quot;https://community.openenergymonitor.org/uploads/default/original/2X/1/1a55b8c172086f743b1b0abe1d01d7c10963d88c.pdf&quot;&gt;Download in PDF format&lt;/a&gt; (6.8 MB)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1qSaxiB2tAgMe3ehQ08E9_r340y9HgHUOYvyUvsHd55I/pub?start=false&amp;amp;loop=false&amp;amp;delayms=3000&quot;&gt;View in HTML (hosted from Google Slides)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1qSaxiB2tAgMe3ehQ08E9_r340y9HgHUOYvyUvsHd55I/edit?usp=sharing&quot;&gt;View in full Google Slides format (with clickable hyperlinks &amp;amp; selectable text)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Glyn Hudson</name></author><summary>Last night I attended EcoHomeLab meetup in Manchester organised by the CarbonCoop.


  EcoHomeLab monthly meetups at MadLab brings householders and green-technologists together to take control of home energy use and generation.


It was great fun to catch up with regular faces as well as meet many new interesting people.

I gave a short presentation overview of our efforts as OpenEnergyMonitor to make it as easy as possible for people to get started with energy monitoring and control (home automation) with a sustainability / energy saving focus.

I presented the recent work we have been doing to integrate platforms such as MQTT, Node-RED and openHAB ready-installed and pre-configured on the emonPi, our RaspberryPi based energy monitoring platform. These additional platforms run alongside Emoncms on the emonPi.

See the Integrations section of our user guide for more info

Here are copy of my slides from the event:




  
    Download in PDF format (6.8 MB)
  
  View in HTML (hosted from Google Slides)
  View in full Google Slides format (with clickable hyperlinks &amp;amp; selectable text)</summary></entry><entry><title>HTU21D / Si72021 Temperature and Humidity Sensor</title><link href="https://blog.openenergymonitor.org/2016/07/HTU21D-Temperature-Humidity-sensor/" rel="alternate" type="text/html" title="HTU21D / Si72021 Temperature and Humidity Sensor" /><published>2016-07-26T10:00:00+00:00</published><updated>2016-07-26T10:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/07/HTU21D-Temperature-Humidity-sensor</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/07/HTU21D-Temperature-Humidity-sensor/">&lt;p&gt;I have been been evaluating the &lt;a href=&quot;https://octopart.com/htu21d-measurement+specialties-30374934&quot;&gt;HTU21D&lt;/a&gt; temperature and humidity sensor made by Measurement Specialties as a possible DHT22 replacement for the emonTH. This is quite a new sensor, released in 2013. The &lt;a href=&quot;https://octopart.com/si7021-a10-gm-silicon+labs-31448011&quot;&gt;Si72021&lt;/a&gt; is also a posiblity with an identical pin-out and specs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/htu21d_1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://octopart.com/htu21d-measurement+specialties-30374934&quot;&gt;OctoPart list&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://datasheet.octopart.com/HTU21D-Measurement-Specialites-datasheet-22149496.pdf&quot;&gt;Datasheet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://uk.farnell.com/measurement-specialties/htu21d/humidity-digital-3-rh-dfn-6/dp/2393536?CMP=GRHB-OCTOPART&quot;&gt;Farnell item&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;DFM footprint&lt;/li&gt;
  &lt;li&gt;Digital, pre-clibrated&lt;/li&gt;
  &lt;li&gt;I2C&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The metrics speak for themselves:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Metric&lt;/th&gt;
      &lt;th&gt;HTU21D&lt;/th&gt;
      &lt;th&gt;Si72021&lt;/th&gt;
      &lt;th&gt;DHT22&lt;/th&gt;
      &lt;th&gt;DHT22 vs HTU21D Difference&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Cost in 1k off&lt;/td&gt;
      &lt;td&gt;£1.42 (July16)&lt;/td&gt;
      &lt;td&gt;£2.15&lt;/td&gt;
      &lt;td&gt;£4.57 (July16)&lt;/td&gt;
      &lt;td&gt;3.2 times cheaper (£3.15 less!)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Vcc&lt;/td&gt;
      &lt;td&gt;2.1v - 3.6V&lt;/td&gt;
      &lt;td&gt;1.9V - 3.6V&lt;/td&gt;
      &lt;td&gt;3.3-6V&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Humidity accuracy&lt;/td&gt;
      &lt;td&gt;±2% RH&lt;/td&gt;
      &lt;td&gt;±2% RH&lt;/td&gt;
      &lt;td&gt;±2%RH&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Humidity Range&lt;/td&gt;
      &lt;td&gt;0-100% RH&lt;/td&gt;
      &lt;td&gt;0-100% RH&lt;/td&gt;
      &lt;td&gt;0-100% RH&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Temperature accuracy&lt;/td&gt;
      &lt;td&gt;±0.3°C&lt;/td&gt;
      &lt;td&gt;±0.4°C&lt;/td&gt;
      &lt;td&gt;±0.5°C&lt;/td&gt;
      &lt;td&gt;40% more accurate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Temperature Range&lt;/td&gt;
      &lt;td&gt;-40°C +125°C&lt;/td&gt;
      &lt;td&gt;-40°C +125°C&lt;/td&gt;
      &lt;td&gt;-40°C +80°C&lt;/td&gt;
      &lt;td&gt;56% more accurate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Sleep Current&lt;/td&gt;
      &lt;td&gt;0.02uA&lt;/td&gt;
      &lt;td&gt;0.06uA&lt;/td&gt;
      &lt;td&gt;15uA&lt;/td&gt;
      &lt;td&gt;750 times less power&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Measurement Current&lt;/td&gt;
      &lt;td&gt;0.045mA&lt;/td&gt;
      &lt;td&gt;0.09 mA&lt;/td&gt;
      &lt;td&gt;0.5mA&lt;/td&gt;
      &lt;td&gt;11 times less power&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Measurement time&lt;/td&gt;
      &lt;td&gt;0.01s - 0.0026s&lt;/td&gt;
      &lt;td&gt;0.01s - 0.0026s&lt;/td&gt;
      &lt;td&gt;2s&lt;/td&gt;
      &lt;td&gt;200 times faster&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Energy consumed per sample&lt;/td&gt;
      &lt;td&gt;1.5uJ&lt;/td&gt;
      &lt;td&gt;2.97uJ&lt;/td&gt;
      &lt;td&gt;3300uJ&lt;/td&gt;
      &lt;td&gt;2000 times less power&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Time sampling per day*&lt;/td&gt;
      &lt;td&gt;14.4s&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;2800s&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Time sleeping per day*&lt;/td&gt;
      &lt;td&gt;86386s&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;83600s&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Energy consumed per day*&lt;/td&gt;
      &lt;td&gt;2.36mW [1]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;2836mW [2]&lt;/td&gt;
      &lt;td&gt;1201 times less energy per day!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;!--more--&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;energy consumed (joule, J) = potential difference (volt, V) × charge (coulomb, C)  
charge (coulomb, C) = current (ampere, A) × time (second, s) 
energy consumed (joule, J)  = potential difference (volt, V) × current (ampere, A) × time (second, s) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;*Assuming 1 sample per min and sleeping in between samples, 1440 min per day = 86400s per day. See HTU21D testing repo a &lt;a href=&quot;https://github.com/openenergymonitor/emonTH/blob/master/sensor_test/htu21d&quot;&gt;sub-repository of the emonTH&lt;/a&gt; for full calculations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;An upgraded emonTH with a HTU21D sensor instead of DHT22 should benefit from substantially increased battery life, increased accuracy and lower cost.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I’ve obtained &lt;a href=&quot;https://www.sparkfun.com/products/retired/12064&quot;&gt;HTU21D Sparkfun breakout to test&lt;/a&gt; and easily got it working with an Arduino using the &lt;a href=&quot;https://github.com/adafruit/Adafruit_HTU21DF_Library&quot;&gt;Adafruit library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/htu21d_2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;There is some confusion with regard to the variants of this sensor &lt;em&gt;I believe&lt;/em&gt; from my research that the HTU21D &lt;strong&gt;replaces&lt;/strong&gt; the &lt;a href=&quot;https://octopart.com/sht21-sensirion-19013846&quot;&gt;SHT21&lt;/a&gt; made by Sensirion. Both sensors have identical pin-outs.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I hope to get a prototype emonTH with HTU21D up and running soon. I would be interested to hear if anyone has experience working with this sensor.&lt;/p&gt;

&lt;p&gt;For disucssion see &lt;a href=&quot;https://community.openenergymonitor.org/t/htu21d-temperature-and-humidity-sensor-possible-dht22-replacement/1106&quot;&gt;HTU21D forum thread.&lt;/a&gt;&lt;/p&gt;</content><author><name>Glyn Hudson</name></author><summary>I have been been evaluating the HTU21D temperature and humidity sensor made by Measurement Specialties as a possible DHT22 replacement for the emonTH. This is quite a new sensor, released in 2013. The Si72021 is also a posiblity with an identical pin-out and specs.




  OctoPart list
  Datasheet
  Farnell item
  DFM footprint
  Digital, pre-clibrated
  I2C


The metrics speak for themselves:


  
    
      Metric
      HTU21D
      Si72021
      DHT22
      DHT22 vs HTU21D Difference
    
  
  
    
      Cost in 1k off
      £1.42 (July16)
      £2.15
      £4.57 (July16)
      3.2 times cheaper (£3.15 less!)
    
    
      Vcc
      2.1v - 3.6V
      1.9V - 3.6V
      3.3-6V
       
    
    
      Humidity accuracy
      ±2% RH
      ±2% RH
      ±2%RH
      n/a
    
    
      Humidity Range
      0-100% RH
      0-100% RH
      0-100% RH
      n/a
    
    
      Temperature accuracy
      ±0.3°C
      ±0.4°C
      ±0.5°C
      40% more accurate
    
    
      Temperature Range
      -40°C +125°C
      -40°C +125°C
      -40°C +80°C
      56% more accurate
    
    
      Sleep Current
      0.02uA
      0.06uA
      15uA
      750 times less power
    
    
      Measurement Current
      0.045mA
      0.09 mA
      0.5mA
      11 times less power
    
    
      Measurement time
      0.01s - 0.0026s
      0.01s - 0.0026s
      2s
      200 times faster
    
    
      Energy consumed per sample
      1.5uJ
      2.97uJ
      3300uJ
      2000 times less power
    
    
      Time sampling per day*
      14.4s
       
      2800s
       
    
    
      Time sleeping per day*
      86386s
       
      83600s
       
    
    
      Energy consumed per day*
      2.36mW [1]
       
      2836mW [2]
      1201 times less energy per day!</summary></entry><entry><title>Part 3/3: Continuous Deployment (Over-The-Air Update to ESP8266)</title><link href="https://blog.openenergymonitor.org/2016/06/esp8266-ota-update/" rel="alternate" type="text/html" title="Part 3/3: Continuous Deployment (Over-The-Air Update to ESP8266)" /><published>2016-06-29T10:00:00+00:00</published><updated>2016-06-29T10:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/06/esp8266-ota-update</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/06/esp8266-ota-update/">&lt;p&gt;&lt;strong&gt;This post is part of a series&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2016/06/platformio/&quot;&gt;1/3 PlatfomIO overview &amp;amp; compiling + uploading locally and on a Raspberry Pi&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2016/06/auto-build-continuous-test-firmware/&quot;&gt;2/3: Continuous testing and auto release binary generation using PlatformIO &amp;amp; TravisCI&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Related post: &lt;a href=&quot;/2016/06/esp8266-emonesp-developments&quot;&gt;EmonESP ESP8266 WiFi developments&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3/3: Continuous Deployment (OTA to ESP8266)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Following on from my last couple of posts in this series we now have a working continuous cloud-based build &amp;amp; test (firmware compiling) flow using PlatformIO and TravisCI, to quickly recap:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Code change is committed to the &lt;a href=&quot;https://github.com/openenergymonitor/EmonESP&quot;&gt;EmonESP repo on GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;TravisCI triggers a build (compile) using PlatformIO running in a TravisCI container in the cloud.&lt;/li&gt;
  &lt;li&gt;If build/compilation process fails we get an email alert, if pull-request we get a warning before merging if proposed changes break the build.&lt;/li&gt;
  &lt;li&gt;If a Git commit is tagged as a release the build process uploads the generated compiled binary (.bin) to the repo GitHub release page.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The next step is to get the compiled binary from GitHub-releases (EmonESP in this example) deployed to a WiFi connected production ESP8266. Here’s the user facing EmonESP web-interface for this firmware update process:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonesp-update.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;The OTA (over-the-air) firmware deployment process is based on Daniel Eichhorn’s (&lt;a href=&quot;https://twitter.com/squix78&quot;&gt;@squix78&lt;/a&gt;) &lt;a href=&quot;http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html&quot;&gt;excellent blog post&lt;/a&gt;. In summary the process is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/esp-update-process.png&quot; alt=&quot;image&quot; /&gt;
Diagram from &lt;a href=&quot;http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html&quot;&gt;Daniel Eichhorn’s blog&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The build is tagged with a version number using PlatformIO build-flag, see EmonESP &lt;a href=&quot;https://github.com/openenergymonitor/EmonESP/blob/master/platformio.ini&quot;&gt;platformio.ini&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;An intermediate PHP script connects to the GitHub API to check the latest release version and returns this as a string.&lt;/li&gt;
  &lt;li&gt;ESP sends it’s current running firmware version to the PHP script using tag argument &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;tag=1.0.2&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If the running firmware version does not match the latest release version, the PHP script grabs the latest release .bin from github-releases API and serves it up as a download to the ESP.&lt;/li&gt;
  &lt;li&gt;ESP then flashes the compiled .bin OTA update using the &lt;a href=&quot;https://github.com/esp8266/Arduino/tree/master/libraries&quot;&gt;ESP8266httpUpdate library&lt;/a&gt; which is built-in to the espressif Arduino tool-chain&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;intermediate-php-script&quot;&gt;Intermediate PHP script&lt;/h3&gt;

&lt;p&gt;Ideally the production ESP8266 would be able to contact the GitHub-release API directly negating the need for the intermediate PHP script. However, there are a number of reasons why this is not practical at the moment. To quote Daniel’s blog post:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;The ESPhttpUpdate currently cannot follow redirects. This is important since github hosts the release artefacts on Amazon AWS. But in the API JSON &amp;gt; object the address points to github, so the http client has to follow a redirect to download the artefact.&lt;/li&gt;
    &lt;li&gt;Github uses https for its API and will redirect you to it if you are trying plain HTTP. This means that you would have to know the SSL fingerprints &amp;gt; of the github API server and the AWS hosting instance since this is required by the ESPs secure client interface. After all the ESPs don’t have a chain &amp;gt; of trusted certificates stored somewhere. While the fingerprint of the github API might be stable, the redirection on Amazon AWS might not always use &amp;gt; the same certificate.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;There is currently working example of this process (ESP8266 firmware + intermediate PHP script) in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ota&lt;/code&gt; branch of &lt;a href=&quot;https://github.com/openenergymonitor/EmonESP&quot;&gt;EmonESP GitHub Repo&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;security&quot;&gt;Security&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;In it’s current implementation the update process described above is not secure.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Obviously secure delivery and verification of the update binary is essential.&lt;/p&gt;

&lt;p&gt;Ideally the binary download to the ESP would be done over secure https. This maybe be possible, however https support on the ESP is currently not super stable and limited by the available memory (as mentioned above).&lt;/p&gt;

&lt;p&gt;A method to verify the compiled binary could be to sign the compiled binary with a private key which is verified by the ESP before firmware is updated.&lt;/p&gt;

&lt;p&gt;I would be interested to hear from anyone with any thoughts / advice as to how secure ESP OTA firmware delivery can be achieved.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Glyn Hudson</name></author><summary>This post is part of a series


  1/3 PlatfomIO overview &amp;amp; compiling + uploading locally and on a Raspberry Pi
  2/3: Continuous testing and auto release binary generation using PlatformIO &amp;amp; TravisCI
    
      Related post: EmonESP ESP8266 WiFi developments
    
  
  3/3: Continuous Deployment (OTA to ESP8266)




Following on from my last couple of posts in this series we now have a working continuous cloud-based build &amp;amp; test (firmware compiling) flow using PlatformIO and TravisCI, to quickly recap:


  Code change is committed to the EmonESP repo on GitHub
  TravisCI triggers a build (compile) using PlatformIO running in a TravisCI container in the cloud.
  If build/compilation process fails we get an email alert, if pull-request we get a warning before merging if proposed changes break the build.
  If a Git commit is tagged as a release the build process uploads the generated compiled binary (.bin) to the repo GitHub release page.


The next step is to get the compiled binary from GitHub-releases (EmonESP in this example) deployed to a WiFi connected production ESP8266. Here’s the user facing EmonESP web-interface for this firmware update process:</summary></entry><entry><title>Emoncms Docker</title><link href="https://blog.openenergymonitor.org/2016/06/emoncms-docker/" rel="alternate" type="text/html" title="Emoncms Docker" /><published>2016-06-25T10:00:00+00:00</published><updated>2016-06-25T10:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/06/emoncms-docker</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/06/emoncms-docker/">&lt;p&gt;We have made the first steps towards running Emoncms to run in a &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; container.&lt;/p&gt;

&lt;p&gt;Dockerfiles and setup notes are in the emoncms-docker repository:&lt;/p&gt;

&lt;h3 id=&quot;httpsgithubcomemoncmsemoncms-dockerhttpsgithubcomemoncmsemoncms-docker&quot;&gt;&lt;a href=&quot;https://github.com/emoncms/emoncms-docker&quot;&gt;https://github.com/emoncms/emoncms-docker&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker-logo.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Docker is an exciting tool to help make development, testing and deployment of web-applications easier.&lt;/p&gt;

&lt;h2 id=&quot;what-is-docker-the-short-version&quot;&gt;What is docker? (the short version):&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Docker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries – anything that can be installed on a server. This guarantees that the software will always run the same, regardless of its environment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;what-is-docker-the-long-version&quot;&gt;What is docker? (the long version):&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Docker is an open-source platform for developers and sysadmins to build, ship, and run distributed applications. Consisting of Docker Engine, a portable, lightweight runtime and packaging tool, and Docker Hub, a cloud service for sharing applications and automating workflows, Docker enables apps to be quickly assembled from components and eliminates the friction between development, QA, and production environments. As a result, IT can ship faster and run the same app, unchanged, on laptops, data center VMs, and any cloud.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker pull openenergymonitor/emoncms
$ git clone https://github.com/emoncms/emoncms-docker
$ cd emoncms-docker
$ docker-compose up
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;That’s it! Emoncms should now be runnning, browse to &lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;emoncms-docker&quot;&gt;Emoncms Docker&lt;/h2&gt;

&lt;p&gt;Using Docker it’s possible to fire up Emoncms on a bare system (assuming Docker is installed) in a couple of minutes with all the LAMP install &amp;amp; config taken care of.&lt;/p&gt;

&lt;p&gt;This is great for development since it’s possible to play about with Emoncms running in a Docker container without fear of messing up your system or production Emoncms install.&lt;/p&gt;

&lt;p&gt;In the future, Docker can even be used as a deployment tool for Emoncms. In theory, it should possible to deploy the Emoncms Docker container on any server within minutes.&lt;/p&gt;

&lt;p&gt;We have taken a multi-container approach with php-apache running in one container and the MYSQL database running in another. The containers are linked using &lt;a href=&quot;https://docs.docker.com/compose/overview/&quot;&gt;docker-compose&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;See &lt;a href=&quot;https://github.com/emoncms/emoncms-docker&quot;&gt;emoncms-docker Readme&lt;/a&gt; for setup &amp;amp; build instructions.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: The Emoncms docker setup is currently in development and not recomended for production Emoncms deployment just yet.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;forum-discussion&quot;&gt;Forum discussion&lt;/h2&gt;

&lt;p&gt;See &lt;a href=&quot;https://community.openenergymonitor.org/t/emoncms-docker/823/4&quot;&gt;this forum topic&lt;/a&gt; for discussion.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Glyn Hudson</name></author><summary>We have made the first steps towards running Emoncms to run in a Docker container.

Dockerfiles and setup notes are in the emoncms-docker repository:

https://github.com/emoncms/emoncms-docker



Docker is an exciting tool to help make development, testing and deployment of web-applications easier.

What is docker? (the short version):


  Docker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries – anything that can be installed on a server. This guarantees that the software will always run the same, regardless of its environment.


What is docker? (the long version):


  Docker is an open-source platform for developers and sysadmins to build, ship, and run distributed applications. Consisting of Docker Engine, a portable, lightweight runtime and packaging tool, and Docker Hub, a cloud service for sharing applications and automating workflows, Docker enables apps to be quickly assembled from components and eliminates the friction between development, QA, and production environments. As a result, IT can ship faster and run the same app, unchanged, on laptops, data center VMs, and any cloud.


Quick Start

$ docker pull openenergymonitor/emoncms
$ git clone https://github.com/emoncms/emoncms-docker
$ cd emoncms-docker
$ docker-compose up



That’s it! Emoncms should now be runnning, browse to http://localhost:8080</summary></entry><entry><title>ESP8266 WIFI developments</title><link href="https://blog.openenergymonitor.org/2016/06/esp8266-emonesp-developments/" rel="alternate" type="text/html" title="ESP8266 WIFI developments" /><published>2016-06-20T10:00:00+00:00</published><updated>2016-06-20T10:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/06/esp8266-emonesp-developments</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/06/esp8266-emonesp-developments/">&lt;p&gt;Glyn and I have been doing a bit of development recently on using the ESP8266 WiFi board with OpenEnergyMonitor hardware, we are quite excited about the potential of this little module to both reduce the cost of the system and simplify setup and installation especially for applications that primarily post to a remote emoncms server such as &lt;a href=&quot;https://emoncms.org&quot;&gt;emoncms.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; we have no plans to discontinue developments and support for Raspberry Pi based systems e.g. emonPi / emonBase. Quite the opposite: the local storage and processing of a Raspberry Pi based system has many advantages particularly for systems requiring more flexibility and customisation e.g Local Emoncms storage. MQTT, openHAB &amp;amp; nodeRED integration. The ESP developments will be ran in parallel, in fact ESP could be configured to post to an emonPi / emonBase via MQTT for local on-site storage and integration.&lt;/p&gt;

&lt;p&gt;We are at the moment working on three initial uses of the ESP8266:&lt;/p&gt;

&lt;h2 id=&quot;emontx-v3--esp8266-module&quot;&gt;1. &lt;strong&gt;EmonTx V3&lt;/strong&gt; + ESP8266 module&lt;/h2&gt;

&lt;p&gt;We are initially using the Adafruit HUZZAH ESP8266 module as a development platform. For anyone keen to get going with the ESP8266 Huzzah module it is available from a number of places such as &lt;a href=&quot;https://www.adafruit.com/product/2471&quot;&gt;adafruit&lt;/a&gt; (USA) and &lt;a href=&quot;https://shop.pimoroni.com/products/adafruit-huzzah-esp8266-breakout&quot;&gt;Pimoroni&lt;/a&gt; (UK). Any ESP8266 with ESP-12 module should work the same. See lower in the post for EmonESP firmware dev.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emontx-esp.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There will be another post very soon detailing how to use this module with the EmonTx v3.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;heatpumpenergy-monitor&quot;&gt;2. Heatpump/Energy Monitor&lt;/h2&gt;

&lt;p&gt;Heatpump / energy monitor through-hole development board, essentially and EmonTx v2 with additional features for interfacing with heat meters and multiple DS18B20 temperature sensors as well as an integrated ESP8266 WIFI module.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/heatpumpmonitor.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The heatpump monitor board currently supports:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;3x CT + ACAC Channels&lt;/li&gt;
  &lt;li&gt;Elster A100C Irda meter reader (watt hours)&lt;/li&gt;
  &lt;li&gt;Pulse Counting&lt;/li&gt;
  &lt;li&gt;Supports MBUS heat meters (Kamstrup 402)&lt;/li&gt;
  &lt;li&gt;Supports SIKA flow meters&lt;/li&gt;
  &lt;li&gt;4x DS18B20 Temperature Sensors&lt;/li&gt;
  &lt;li&gt;Miniature solid state relay for heating control (not yet tested)&lt;/li&gt;
  &lt;li&gt;ESP8266 Low cost Wifi&lt;/li&gt;
  &lt;li&gt;RFM69 option&lt;/li&gt;
  &lt;li&gt;Raspberry PI connector option&lt;/li&gt;
  &lt;li&gt;A Through-hole ESP Wifi development platform&lt;/li&gt;
  &lt;li&gt;Fits in the EmonTx V3 Aluminum case&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Guide cost ~£50 (ex VAT) for full heatpump monitor kit with case, ~£30 (ex VAT) for cut down WIFI energy monitor only kit without case.. To be finalised.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/openenergymonitor/HeatpumpMonitor&quot;&gt;See Heatpump monitor development repo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;esp8266-based-wifi-pixel-energy-display&quot;&gt;3. ESP8266 based WIFI Pixel Energy Display,&lt;/h2&gt;

&lt;p&gt;This is an idea thanks to David Hunninsett (&lt;a href=&quot;http://twitter.com/m0untainpenguin&quot;&gt;@m0untainpenguin&lt;/a&gt;) with hardware being developed by &lt;a href=&quot;https://github.com/Protoneer/WifiPixels&quot;&gt;Protoneer&lt;/a&gt;. It fits into a project we are more recently part of here in North Wales called &lt;a href=&quot;http://www.energylocal.co.uk/cydynni/&quot;&gt;CydYnni by EnergyLocal&lt;/a&gt; where 100 households within the boundary of the substation get cheap electricity when a local community hydro is running. David Hunninsett is one of the households on the project and he is keen to have a display that shows when it’s a good time to use electricity among other uses. The wifi pixel could become a nice platform for a ambient home energy indicator.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wifi-pixel1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wifi-pixel2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://community.openenergymonitor.org/uploads/default/original/1X/c72e375230597049c0d8a9e06645a8d088d70774.mp4&quot;&gt;See video&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/davehun/mqtt-wifi-pixel&quot;&gt;See software development  repo on&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;emonesp-easier-setup-and-installation&quot;&gt;EmonESP, easier setup and installation&lt;/h1&gt;

&lt;p&gt;One of the really nice things about using the ESP module is that it can really simplify setup for installations that only need to post to a remote emoncms server. The wifi module starts by broadcasting a hotspot that you connect to directly, you can then scan for wifi networks, select the network, get the ip address of the monitor on the network (which saves using fing or accessing your router device list), enter your emoncms.org apikey to connect to an emoncms.org account (to be replaced with username and passowrd login + ability to register and link the monitor to a emoncms account in one step).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonesp.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We plan to extend EmonESP to also support MQTT.&lt;/p&gt;

&lt;p&gt;The EmonESP software is based on work by Chris Howel of &lt;a href=&quot;http://www.openevse.com&quot;&gt;OpenEVSE&lt;/a&gt; which is a really nice open hardware electric vehicle charging station, it’s been really nice to find a common development like this that can be beneficial to two open hardware and software projects. OpenEVSE &lt;a href=&quot;https://data.openevse.com/&quot;&gt;already use Emoncms&lt;/a&gt; for logging and graphing.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/openenergymonitor/emonesp&quot;&gt;EmonESP firmware developments can be found on github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;over-the-air-firmware-upload&quot;&gt;Over the air firmware upload&lt;/h2&gt;

&lt;p&gt;Glyn has been doing a lot of work on how we can do over the air updates to ESP8266 based units. Being able to do this will make it a lot easier to maintain and keep the firmware on these updated especially as the software goes through the larger number of iterations in initial development. Check out his blog posts here to follow the development:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.openenergymonitor.org/2016/06/platformio/&quot;&gt;Part 1/3: PlatformIO open-source embedded development ecosystem&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware&quot;&gt;Part 2/3: Firmware Continuous Test &amp;amp; Build&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;3/3: Continuous Deployment (OTA to ESP8266) &lt;em&gt;…In the making!&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;forum-discussion&quot;&gt;Forum discussion&lt;/h2&gt;

&lt;p&gt;See &lt;a href=&quot;https://community.openenergymonitor.org/t/esp8266-wifi-developments/784&quot;&gt;this forum topic&lt;/a&gt; for discussion.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Trystan Lea</name></author><summary>Glyn and I have been doing a bit of development recently on using the ESP8266 WiFi board with OpenEnergyMonitor hardware, we are quite excited about the potential of this little module to both reduce the cost of the system and simplify setup and installation especially for applications that primarily post to a remote emoncms server such as emoncms.org.

Note: we have no plans to discontinue developments and support for Raspberry Pi based systems e.g. emonPi / emonBase. Quite the opposite: the local storage and processing of a Raspberry Pi based system has many advantages particularly for systems requiring more flexibility and customisation e.g Local Emoncms storage. MQTT, openHAB &amp;amp; nodeRED integration. The ESP developments will be ran in parallel, in fact ESP could be configured to post to an emonPi / emonBase via MQTT for local on-site storage and integration.

We are at the moment working on three initial uses of the ESP8266:

1. EmonTx V3 + ESP8266 module

We are initially using the Adafruit HUZZAH ESP8266 module as a development platform. For anyone keen to get going with the ESP8266 Huzzah module it is available from a number of places such as adafruit (USA) and Pimoroni (UK). Any ESP8266 with ESP-12 module should work the same. See lower in the post for EmonESP firmware dev.



There will be another post very soon detailing how to use this module with the EmonTx v3.</summary></entry><entry><title>Part 2/3: Firmware Continuous Test &amp;amp; Build</title><link href="https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware/" rel="alternate" type="text/html" title="Part 2/3: Firmware Continuous Test &amp; Build" /><published>2016-06-14T10:00:00+00:00</published><updated>2016-06-14T10:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/06/auto-build-continuous-test-firmware/">&lt;p&gt;&lt;strong&gt;This post is part of a series&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2016/06/platformio/&quot;&gt;1/3 PlatfomIO overview &amp;amp; compiling + uploading locally and on a Raspberry Pi&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2/3: Continuous testing and auto release binary generation using PlatformIO &amp;amp; TravisCI&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2016/06/esp8266-ota-update/&quot;&gt;3/3: Continuous Deployment (OTA to ESP8266)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Following on from the &lt;a href=&quot;https://blog.openenergymonitor.org/2016/06/platformio/&quot;&gt;last blog post&lt;/a&gt; on using &lt;a href=&quot;https://blog.openenergymonitor.org/2016/06/platformio/&quot;&gt;PlatformIO&lt;/a&gt; to compile and upload firmware locally, we’re now going to take things a step further and do the same but in &lt;em&gt;The Cloud&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Groan…I know I just used the clichéd ‘C’ word, however there are many advantages to compiling and testing the code in the cloud. At least I didn’t mention ‘IoT’…whoops, just doing my bit for SEO!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this instance when we say &lt;em&gt;‘compile in the cloud’&lt;/em&gt; I mean use GitHub, &lt;a href=&quot;https://travis-ci.org&quot;&gt;Travis IO&lt;/a&gt; and &lt;a href=&quot;https://platformio.org&quot;&gt;PlatfromIO&lt;/a&gt; to compile the firmware and if the branch is tagged with a ‘Git Release’ auto-generate a compiled binary and upload it back to GitHub release page.&lt;/p&gt;

&lt;p&gt;The motivation behind this automated-build and testing is working towards creating a robust infrastructure to push OTA updates to ESP8266 connected nodes (&lt;a href=&quot;https://github.com/openenergymonitor/EmonESP&quot;&gt;EmonESP dev&lt;/a&gt;) inspired by &lt;a href=&quot;http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html&quot;&gt;this blog post&lt;/a&gt; by Daniel Eichhorn (&lt;a href=&quot;https://twitter.com/squix78&quot;&gt;@squix78&lt;/a&gt;).&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;The advantages of &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_testing&quot;&gt;continuous testing&lt;/a&gt; have been long established in the software industry. The test we are performing is &lt;em&gt;‘does this firmware compile?’&lt;/em&gt;; obviously this is not a comprehensive test but it will at least give us confidence that there are no syntax errors etc. To actually test operation of embedded firmware, physical hardware (or simulation) would be required.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;A commit or pull request is made to the firmware repository on GitHub
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;To date emonPi, emonTx and EmonESP repositories have been enabled for continuous build &amp;amp; test&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This triggers Travis CI to start a ‘build’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Code compilation is generated using platformIO in the same way as when compiling locally, &lt;a href=&quot;https://blog.openenergymonitor.org/2016/06/platformio/&quot;&gt;See blog post&lt;/a&gt;. The &lt;a href=&quot;https://github.com/openenergymonitor/emonpi/blob/master/.travis.yml&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.travis.yml&lt;/code&gt; file in the repo&lt;/a&gt; configures the Travis CI build using platformIO:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;language: python
python:
- &#39;2.7&#39;
sudo: false
cache:
  directories:
  - &quot;~/.platformio&quot;
install:
- pip install -U platformio
script:
- platformio run -d firmware -e emonpi_deploy
deploy:
  on:
    repo: openenergymonitor/emonpi
    all_branches: true
    condition: $TRAVIS_TAG =~ ^[0-9]+\.[0-9]+\.[0-9]+$
  skip_cleanup: true
  provider: releases
  overwrite: true
  api_key:
    secure: OzNwxsQEVlSj2e4sOqKNYlNXqPqc5myL0nOBtY1FYD+sbxslHMixmlRASWuFMCjHdpFYQST2IuR3UMCPCjfPzMDVCVtsJ8VPd299fgDGzmEnL3P5Z8wCAv1CfHURcfXzFJDM7prevGx9cfz8uAiwIaNOhbTL7kL2GfSatV5PERzr2ytVh6WUj650Rd7bLKKhj8YHOzO9wOBoKDadYDFF99XYQbDDoHj9pAv+OPG76X0kWrdrq/0w26jh7JZaxrwhF/xD7maGaEjLOa/FcXbyZlVy/JIFjyrKp79swzVNSFNox/CbF7e6tzBf3NhZsoQyEchnCrgWw8IB7j/Ja7Ypetn6IG7C5rT/h46rWrZshbVdw7ZBUzhNJIUVLHFBy7hi2hxMw9Bn+oCt0UWLt8SnQnRfAbjw+z3XQ2/6MccUAINKGDqd4fm9M85sN6drpXySeJ/ZyRkdlUN0xsDpARI05mYLLlCutRzlSCkglbsKJr5XM7h7pXHLUQY5dfw9LrA788w25OBoO9U8vCKtoV8UCXWh6og/364CRl9Uih958f1t7kHIvfwLJjwSDFYVxUsyvSFyjfY+pIfuGEXtgIqMZ87nK3O1vAb9udbPErp0q5kJBeks9Df6wVsvjI7O++7YwiSuWlJBD0x45ZV9pxOFLnWb1hetHpPH5kFgBlTDqsY=
  file: &quot;firmware/.pioenvs/emonpi_deploy/firmware.hex&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;If the build fails for whatever reason (syntax error, library error etc) then the green &lt;code class=&quot;highlighter-rouge&quot;&gt;build passing&lt;/code&gt; icon changes to a ominous red &lt;code class=&quot;highlighter-rouge&quot;&gt;build Failed&lt;/code&gt; and we get an alert email. For a full build log example see the &lt;a href=&quot;https://travis-ci.org/openenergymonitor/emonpi&quot;&gt;emonPi Travis CI build page&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/openenergymonitor/emonpi&quot;&gt;&lt;img src=&quot;https://travis-ci.org/openenergymonitor/emonpi.svg?branch=master&quot; alt=&quot;Build Status&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If the GitHub branch is tagged with a ‘release tag’ and compilation is successful then the generated &lt;code class=&quot;highlighter-rouge&quot;&gt;.hex&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;.bin&lt;/code&gt; is uploaded to the GitHub release page:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonpi-draft-release.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonpi-travis-release.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For a detailed explanation of how the release binary is generated and deployed see Daniel Eichhorn’s (&lt;a href=&quot;https://twitter.com/squix78&quot;&gt;@squix78&lt;/a&gt;) &lt;a href=&quot;http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html&quot;&gt;excellent blog post&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Stay tuned for part 3/3 of the PlatformIO firmware work-flow post series, which will cover auto deploying (OTA) the compiled firmware release onto an ESP8266. For a sneak peak checkout &lt;a href=&quot;http://blog.squix.org/2016/06/esp8266-continuous-delivery-pipeline-push-to-production.html&quot;&gt;this excellent blog post&lt;/a&gt; which was a source of inspiration and information.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Glyn Hudson</name></author><summary>This post is part of a series


  1/3 PlatfomIO overview &amp;amp; compiling + uploading locally and on a Raspberry Pi
  2/3: Continuous testing and auto release binary generation using PlatformIO &amp;amp; TravisCI
  3/3: Continuous Deployment (OTA to ESP8266)




Following on from the last blog post on using PlatformIO to compile and upload firmware locally, we’re now going to take things a step further and do the same but in The Cloud!

Groan…I know I just used the clichéd ‘C’ word, however there are many advantages to compiling and testing the code in the cloud. At least I didn’t mention ‘IoT’…whoops, just doing my bit for SEO!

In this instance when we say ‘compile in the cloud’ I mean use GitHub, Travis IO and PlatfromIO to compile the firmware and if the branch is tagged with a ‘Git Release’ auto-generate a compiled binary and upload it back to GitHub release page.

The motivation behind this automated-build and testing is working towards creating a robust infrastructure to push OTA updates to ESP8266 connected nodes (EmonESP dev) inspired by this blog post by Daniel Eichhorn (@squix78).</summary></entry><entry><title>Part 1/3: PlatformIO open-source embedded development ecosystem</title><link href="https://blog.openenergymonitor.org/2016/06/platformio/" rel="alternate" type="text/html" title="Part 1/3: PlatformIO open-source embedded development ecosystem" /><published>2016-06-12T10:00:00+00:00</published><updated>2016-06-12T10:00:00+00:00</updated><id>https://blog.openenergymonitor.org/2016/06/platformio</id><content type="html" xml:base="https://blog.openenergymonitor.org/2016/06/platformio/">&lt;p&gt;&lt;strong&gt;This post is part of a series:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;1/3: PlatfomIO overview &amp;amp; compiling + uploading locally and on a Raspberry Pi&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2016/06/auto-build-continuous-test-firmware/&quot;&gt;2/3: Continuous testing and auto release binary generation using PlatformIO &amp;amp; TravisCI&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Related post: &lt;a href=&quot;/2016/06/esp8266-emonesp-developments&quot;&gt;EmonESP ESP8266 WiFi developments&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2016/06/esp8266-ota-update/&quot;&gt;3/3: Continuous Deployment (OTA to ESP8266)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Getting an Arduino based project (or other embedded platform) to compile and upload can be a pain. Making sure all the libraries are installed in the correct locations and are the correct versions can be tricky and time-consuming.&lt;/p&gt;

&lt;p&gt;I’m sure many developers will agree that the tools we use for embedded development are generally not as good as those used for web application development.&lt;/p&gt;

&lt;p&gt;The Arduino team have done a good job with their IDE to try and make the embedded development tool-chain setup as easy as possible. However, I still find library management a cause of frustration. Especially since I move between computers and OS’s frequently.&lt;/p&gt;

&lt;p&gt;Recently I have been using &lt;a href=&quot;http://platformio.org&quot;&gt;PlatformIO&lt;/a&gt; and am rather impressed with the ease of setup, speed of compilation, uploading (auto port detection), and most importantly an excellent &lt;a href=&quot;http://platformio.org/lib&quot;&gt;library manager&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PlatformIO is an open-source ecosystem for IoT development.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cross-platform build system, IDE integration and continuous testing. Arduino, Espressif, ARM and mbed compatible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/pio-ide.png&quot; alt=&quot;PlatformIO IDE&quot; /&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Here are some things that have impressed me about PlatformIO (pio) after using it for a couple of weeks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/platformio&quot;&gt;&lt;strong&gt;Fully open-source&lt;/strong&gt;&lt;/a&gt; with active and friendly dev community.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Easy to install&lt;/strong&gt; - Pure python based, installed using pip
    &lt;ul&gt;
      &lt;li&gt;Tool-chains are auto installed on first compile / upload e.g.
        &lt;ul&gt;
          &lt;li&gt;If trying to upload to Arduino avrdude will automatically be installed&lt;/li&gt;
          &lt;li&gt;If trying to compile an ESP8266 project the ESP toolchain will be installed&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cross-platform (Linux, Windows and mac all work the same), this will make support much easier&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Supports all the main embedded platforms&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;atmelavr (Arduino), espressif (ESP8266), ststm32 (ARM etc.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Command line and IDE&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;At work I use pio via Atom IDE on Ubuntu&lt;/li&gt;
      &lt;li&gt;At home, I use a Chromebook with Caret IDE and interact with pio via command-line&lt;/li&gt;
      &lt;li&gt;When developing directly on an emonPi / RaspberryPi pio command-line works great - &lt;em&gt;Yes, that’s right pio works on a RaspberryPi to compile and upload code directly!&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://platformio.org/lib&quot;&gt;&lt;strong&gt;Excellent library manager&lt;/strong&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Libraries can be searched and reviewed using command-line or web 2.0 manager&lt;/li&gt;
      &lt;li&gt;Required libraries can be specified in the &lt;code class=&quot;highlighter-rouge&quot;&gt;platformio.ini&lt;/code&gt; file and if not present install is prompted upon compilation&lt;/li&gt;
      &lt;li&gt;Specific library version (as defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;library.json&lt;/code&gt; &lt;a href=&quot;https://github.com/openenergymonitor/EmonLib/blob/master/library.json&quot;&gt;(emonLib example)&lt;/a&gt;) or git commit SHA&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fast compilation &amp;amp; pain-free uploading&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;PlatformIO’s compiler is the &lt;a href=&quot;https://twitter.com/krzychb2/status/729294573760065536&quot;&gt;fastest in the business&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;USB / Serial ports auto detected&lt;/li&gt;
      &lt;li&gt;Since the emonPi has been added as a custom board PlatformIO can even upload direct to emonPi via RaspberryPi GPIO and trigger GPIO AVR reset, not more &lt;a href=&quot;https://github.com/openenergymonitor/avrdude-rpi&quot;&gt;hacked avrdude&lt;/a&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Easy integration with continuous testing &amp;amp; deployment&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Integration with TravisCI to enable compilation, code testing and binary (.hex / .bin) release generation in the cloud.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://github.com/openenergymonitor/emonpi/&quot;&gt;emonPi&lt;/a&gt; and &lt;a href=&quot;github.com/openenergymonitor/emonTxFirmware&quot;&gt;emonTx&lt;/a&gt; git repos are now enabled for continous-testing and auto binary generation on release tag…this is a step change in embedded development.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;example-compiling-emontx--emonpi-firmware&quot;&gt;Example: Compiling emonTx / emonPi firmware&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.platformio.org/en/latest/quickstart.html&quot;&gt;PlatformIO has some excellent quick start docs&lt;/a&gt; to cover setting up your first ‘blinky’ project, therefore I will not duplicate here. In this example I focus on setting up pio and compiling emonTx / emonPi firmware. This example assumes a totally bare metal machine with nothing installed except python (2.7 recommended). Pio works great on a Raspberry Pi.&lt;/p&gt;

&lt;p&gt;This guide used command-line steps on Linux, if using Windows or if you want to use the platformio IDE see &lt;a href=&quot;http://platformio.org/get-started&quot;&gt;PlatformIO Getting Started Page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The PlatformIO IDE or Atom IDE is excellent and very easy to use (self explanatory). This guide uses pio via command line as this gives a more hands-on experience to how pio is working.&lt;/p&gt;

&lt;h3 id=&quot;install-platformio&quot;&gt;1. Install PlatformIO&lt;/h3&gt;

&lt;p&gt;The easiest way if running Linux is to use the install script, this installs pio via python pip and installs pip if not present. See &lt;a href=&quot;http://docs.platformio.org/en/latest/installation.html#installer-script&quot;&gt;PlatformIO installation docs&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo python -c &quot;$(curl -fsSL https://raw.githubusercontent.com/platformio/platformio/master/scripts/get-platformio.py)&quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;clone-emontx--emonpi-repo&quot;&gt;2. Clone emonTx / emonPi repo&lt;/h3&gt;

&lt;p&gt;We’ll use the emonTx (V3 discrete sampling) as an example here but the steps are exactly the same for emonPi.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;emonTx V3&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/openenergymonitor/emonTxFirmware`
$ cd emonTxFirmware/emonTxV3/RFM/emonTxV3.4/emonTxV3_4_DiscreteSampling
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;emonPi&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/openenergymonitor/emonpi`
cd emonpi/firmware
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;compile-with-platformio&quot;&gt;3. Compile with PlatformIO&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ platformio run&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or shorthand for the lazy&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ pio run&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;That’s it!&lt;/strong&gt; That’s all that’s needed to setup pio from scratch and compile emonTx firmware :-D&lt;/p&gt;

&lt;p&gt;The first time platformIO is run it will ask to install the required libraries (versions specified) and AVR toolchain. The required libraries are defined in &lt;a href=&quot;https://github.com/openenergymonitor/emonTxFirmware/blob/master/emonTxV3/RFM/emonTxV3.4/emonTxV3_4_DiscreteSampling/platformio.ini&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;platformio.ini&lt;/code&gt; in the emonTx discrete sampling firmware folder&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lib_deps_external =
  DHT sensor library @1.2.3
  DallasTemperature @3.7.7
  EmonLib
  JeeLib@c057b5f4c0
  LiquidCrystal_I2C @4bb48bd648
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The latest version of the libraries are automatically cloned from their native git repos into the &lt;code class=&quot;highlighter-rouge&quot;&gt;~/platformio&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;If required specific versions can be installed e.g.:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pio lib install 252 --version=&quot;e70c9d9f4e&quot;
$ platformio lib install 54 --version=&quot;3.7.7&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;upload-using-platformio&quot;&gt;3. Upload using PlatformIO&lt;/h3&gt;

&lt;h4 id=&quot;a-via-usb-to-uart-programmer-to-emontx&quot;&gt;3a. Via USB to UART programmer to emonTx&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo platformio run --target upload&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or lazy shorthand&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo pio run -t upload&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Pio will attempt to auto detect the USB programmer and upload :-)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: you will need &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; unless you have correctly &lt;a href=&quot;https://github.com/platformio/platformio/blob/develop/scripts/99-platformio-udev.rules&quot;&gt;configured udev rules&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To list available serial ports:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ pio serialports list&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There is even a built in serial monitor&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ pio serialports monitor&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;b-using-ttyama0-gpio-to-upload-direct-to-emonpi&quot;&gt;3b. Using ttyAMA0 GPIO to upload direct to emonPi&lt;/h3&gt;

&lt;p&gt;This is where things get very exciting, pio can compile the code directly on a Raspberry Pi. The latest version of pio (&lt;del&gt;due to be released in the next few weeks&lt;/del&gt;, &lt;a href=&quot;https://community.platformio.org/t/platformio-cli-2-10-0/381&quot;&gt;released 2.10.0&lt;/a&gt;) will have built in support for the emonPi auto-reset on upload using GPIO4. See &lt;a href=&quot;http://platformio.org/boards?count=1000&amp;amp;filter%5Bname%5D=emonpi&amp;amp;page=1&amp;amp;sorting%5Bvendor%5D=asc&quot;&gt;emonPi listed on PlatformIO boards page&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/emonpi-platformio.png&quot; alt=&quot;emonpi-platformio.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The emonPi board is defined in &lt;code class=&quot;highlighter-rouge&quot;&gt;platformio.ini&lt;/code&gt; in the &lt;a href=&quot;https://github.com/openenergymonitor/emonpi/blob/master/firmware/platformio.ini&quot;&gt;emonpi/firmware folder&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;board = emonpi
upload_port = /dev/ttyAMA0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All that is needed to compile and upload directly on the emonPi is:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/emonpi/firmware
$ sudo service emonhub stop
$ sudo pio run -t upload
$ sudo service emonhub start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Thanks a lot to &lt;a href=&quot;https://github.com/ivankravets&quot;&gt;Ivan Kravets&lt;/a&gt; for helping integrate emonPi into the PlatfomIO ecosystem. &lt;a href=&quot;https://github.com/platformio/platformio/commit/c5b5e80de4928cf91be59e675429b520e31d873a&quot;&gt;View commit changes&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Stay tuned for part 2/3 of the PlatformIO post series which will cover setting up firmware continuous testing using Travis CI and auto compiled binary generation on release tag directly on github. This is currently live on the emonPi &amp;amp; emonTx repos if you want a sneak preview. See &lt;a href=&quot;https://github.com/openenergymonitor/emonpi/blob/master/.travis.yml&quot;&gt;travis.yaml&lt;/a&gt; file and Travis build status icon on the main emonpi repo &lt;a href=&quot;https://github.com/openenergymonitor/emonpi/blob/master/README.md&quot;&gt;Readme.md&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Glyn Hudson</name></author><summary>This post is part of a series:


  1/3: PlatfomIO overview &amp;amp; compiling + uploading locally and on a Raspberry Pi
  2/3: Continuous testing and auto release binary generation using PlatformIO &amp;amp; TravisCI
    
      Related post: EmonESP ESP8266 WiFi developments
    
  
  3/3: Continuous Deployment (OTA to ESP8266)




Getting an Arduino based project (or other embedded platform) to compile and upload can be a pain. Making sure all the libraries are installed in the correct locations and are the correct versions can be tricky and time-consuming.

I’m sure many developers will agree that the tools we use for embedded development are generally not as good as those used for web application development.

The Arduino team have done a good job with their IDE to try and make the embedded development tool-chain setup as easy as possible. However, I still find library management a cause of frustration. Especially since I move between computers and OS’s frequently.

Recently I have been using PlatformIO and am rather impressed with the ease of setup, speed of compilation, uploading (auto port detection), and most importantly an excellent library manager.


  PlatformIO is an open-source ecosystem for IoT development.



  Cross-platform build system, IDE integration and continuous testing. Arduino, Espressif, ARM and mbed compatible.</summary></entry></feed>
